#!/usr/bin/env bash

#1 config

git config --global user.name "Ciro Duran Santilli"
git config --global user.email "ciro.santilli@gmail.com"

#1 init

git init
# starts a repository here

GITHUB_ID=cirosantilli
REPO_NAME=python
git remote add github "git@github.com:cirosantilli/python.git"
git remote add bitbucket "https://cirosantilli@bitbucket.org/cirosantilli/testrepo0.git"
# allows to push and pull current repo git@github.com:cirosantilli/python.git repo.
# this repo gets an alias github. see #1 push for details

#1 remote

git remote add github https://github.com/cirosantilli/latex.git
# create a remote branch at github called github

git remote show
# view all names of remote branches

git remote rm github
# remove the branch github (if you for isntance entered the bad url, you will have to first remove the old one before you can add the correct url)

#1 adding files

find . -maxdepth 1 -type f -exec git add "{}" +
# add all directly in current dir to git 

find . -name '.git' -prune -o -type f -name '*.py' -exec git add "{}" +
find . -name '.git' -prune -o -type f -name '*.py' -print0 | xargs -0 git add
# adds all python files to git. ignores the .git folder itself
# useful if you have files in subfolder (such as python modules). if all files are in the root folder, consider a simpler -maxdepth

#1 move and rename: mv

git mv "$OLD_PATH" "$NEW_PATH"
# move OLD_PATH to NEW_PATH. if the new path already exists, nothing is done.
# use -f to force overwrite

git mv -f "$OLD_PATH" "$NEW_PATH"
# if the new path exists, it is overwritten

#1 remove rm

git rm "$PATH"
# stop tracking file and permanently delete it on disk.
# only works if the files has not been modified after last commit. If it has, you must use the -f option.
# if the file exist but is not being tracked, nothing is done

git rm --cached "$PATH"
# stop tracking file, but keep source

git rm -f "$PATH"
# rm even if the file has been modified after last commit, thus possible resulting is loss of data
# if the file is not being tracked, nothing is done

git rm -r "$PATH"
# recurse remove into directories

git ls-files --deleted -z | xargs -0 git rm
# removes only tracked files that were mannualy deleted.
# this might be useful since if you try to remove an untracked file with git, nothing happens

#1 commit

# after you commit, you can push you modifications to somewhere else, and you can also come back in time to this commit.

git commit -a -v
# -a: commits all files that have been modified or deleted (if deleted they will stop being tracked for the future)
# -v: opens vim in a commit diff log. you can either enter a commit message on the first line, or leave it blank and cancel comit. action is taken after you save ans quit :wq

git commit -a -m 'commit message'
# same as above, but commits directly with message commit message

git status
# see uncommited file changes and untracked files

#1 time travel

git log	# see hashes of versions
git reset -hard	# go back to last commit and lose all
git reset -hard [START OF HASH]	# go back to hashe's commit and lose all that comes after it
git checkout master # go back to last  commit and lose uncommited changes
git checkout [START OF HASH] # go back to given Hash and KEEP changes. new commits will start branches

#1 pull

git pull github master
# pulls from github repository with alias github to here
# you might need to merge to do this

#1 push

git push github master
# pushes to github repository with alias github from here
# you must pull before you push!

#- tags
git tag "v1.3"
git push --tags
