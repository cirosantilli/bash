#!/usr/bin/env bash

#sources
  #http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging

#config

  git config --global user.name "Ciro Duran Santilli"
  git config --global user.email "ciro.santilli@gmail.com"

#init

  git init
  #starts a repository here

  git remote add github "git@github.com:cirosantilli/python.git"
  git remote add bitbucket "https://cirosantilli@bitbucket.org/cirosantilli/testrepo0.git"
  #allows to push and pull current repo git@github.com:cirosantilli/python.git repo.
  #this repo gets an alias github. see #1 push for details

#remote

  git remote add github https://github.com/cirosantilli/latex.git
  #create a remote branch at github called github

  git remote 
  #shows remote repo aliases without their real addresses

  git remote -v
  #shows remote repo aliases and their real addresses

  git remote show
  #view all names of remote branches

  git remote show "$B"
  #view detail of branch

  git remote rm github
  #remove the branch github (if you for isntance entered the bad url, you will have to first remove the old one before you can add the correct url)

#adding files

  find . -maxdepth 1 -type f -exec git add "{}" +
  #add all directly in current dir to git 

  find . -name '.git' -prune -o -type f -name '*.py' -exec git add "{}" +
  find . -name '.git' -prune -o -type f -name '*.py' -print0 | xargs -0 git add
  #adds all python files to git. ignores the .git folder itself
  #useful if you have files in subfolder (such as python modules). if all files are in the root folder, consider a simpler -maxdepth

#move and rename: mv

  git mv "$OLD_PATH" "$NEW_PATH"
  #move OLD_PATH to NEW_PATH. if the new path already exists, nothing is done.
  #use -f to force overwrite

  git mv -f "$OLD_PATH" "$NEW_PATH"
  #if the new path exists, it is overwritten

  git mv -k "$OLD_PATH" "$NEW_PATH"
  #if moving would lead to an error (overwrite without -f or file not tracked), skip the move

#remove rm

  git rm "$PATH"
  #stop tracking file and permanently delete it on disk.
  #only works if the files has not been modified after last commit. If it has, you must use the -f option.
  #if the file exist but is not being tracked, nothing is done

  git rm --cached "$PATH"
  #stop tracking file, but keep source

  git rm -f "$PATH"
  #rm even if the file has been modified after last commit, thus possible resulting is loss of data
  #if the file is not being tracked, nothing is done

  git rm -r "$PATH"
  #recurse remove into directories

  git ls-files --deleted -z | xargs -0 git rm
  #removes only tracked files that were mannualy deleted.
  #this might be useful since if you try to remove an untracked file with git, nothing happens

#commit

  #after you commit, you can push you modifications to somewhere else, and you can also come back in time to this commit.

  git commit -a -v
  #-a: commits all files that have been modified or deleted (if deleted they will stop being tracked for the future)
  #-v: opens vim in a commit diff log. you can either enter a commit message on the first line,
  #  or leave it blank and cancel comit. action is taken after you save ans quit :wq

  git commit -am 'commit message'
  #same as above, but commits directly with message commit message

  git status
  #see uncommited file changes and untracked files

#time travel

  git log	#see hashes of versions
  git log -p $file #history for a given file
  git log --follow -p file #idem, but also goes back on renames

  git checkout $hash #go back to given Hash and KEEP changes. new commits will start branches
  git checkout master #go back to last commit and lose uncommited changes on all files
  git checkout $hash #go back to hash (beginning of hash). lose uncommited
  git checkout $hash -- $file1 $file2
  #  master :
  #  start of hash (4,6 chars, such as 1ab4)
  #  HEAD: most recent
  #  HEAD^: before most recent
  #  tag: version tag, usually versions such as v.1.2.

  #revert only those files
  #if they had different names/location back then, you must put the old names
  #  and they will be restored under the old names/location

  git reset -hard	#go back to last commit and lose all changes made afterwards
  git reset -hard $hash #go back to hashe's commit and lose all that comes after it

#pull
  git pull github master
  #pulls from github repository with alias github to here
  #you might need to merge to do this

#push
  git push "$R" "$B"
  git push github master
  #push branch B to remote R

  #- tags
  git tag "v1.3"
  git push --tags

#branch and merge
  git branch
  #show branches. * before current

  git branch "$B"
  #create a branch

  git checkout "$B"
  #go to that branch

  git checkout -b "$B"
  #create a branch an go to it

  git branch -d "$B"
  #delete a branch after it gets old

  git checkout master
  git merge "$B"
  #merge master with another branch 
  #if auto merge is fine
    #master goes to new node created after merge
  #else
    git status
    #shows what was unmerged
      #needs merge
    #files get modified to contain trash merge markers
    git mergetool
    #open with a merging tool

#remove mistaken push of sensitive data to github
  UNAME=cirosantilli
  REPONAME=python
  REPOURL=https://github.com/$UNAME/$REPONAME.git
  RMFILE=

  git filter-branch --index-filter "git rm --cached --ignore-unmatch \"$RMFILE\"" --prune-empty -- --all
  git push github master --force

  #remove from local dir
  rm -rf .git/refs/original/
  git reflog expire --expire=now --all
  git gc --prune=now
  git gc --aggressive --prune=now
  #MAIL ALL COLABORATORS AN TELL THEM TO git rebase

#submodule

  #use outside repos inside you main repo,
  #if you modify the outside repo, it is easy to push it back to its origin by itself!
  #commands outside of the submodule (log, diff, etc) don't see what goes on inside it
  #commands inside it do!

  #add new submodule to project
    git submodule add git://github.com/chneukirchen/rack.git rack
    #add an external submodule to dir named rack

  #clone project with submodule:
    git clone git://github.com/schacon/myproject.git #submodule is empty
    git submodule init #create .gitmodule
    git submodule update #get module from server

  #remove

      vim .submodules
      #Delete the relevant section from the .gitmodules file.

      vim .git/config
      #Delete the relevant section from .git/config.

      rm --cached $path_to_submodule #(no trailing slash).

      rm -Rf .git/modules/$path_to_submodule

      git commit -am 'removed submodule'

      rm -rf $path_to_submodule

#github api v3 via curl

  USER=cirosantilli
  REPO=repo
  PASS=

  #get repo info (large)
    curl -i https://api.github.com/users/$USER/repos

  #create remote git repo

    curl -u "$USER" https://api.github.com/user/repos -d '{"name":"'$REPO'"}'
    git remote add github git@github.com:$USER/$REPO.git
    git push origin master

    #{
      #"name": "$REPO",
      #"description": "This is your first repo",
      #"homepage": "https://github.com",
      #"private": false,
      #"has_issues": true,
      #"has_wiki": true,
      #"has_downloads": true
    #}

  #delete repo
    curl -u "$USER" -X DELETE https://api.github.com/repos/$USER/$REPO
    #careful, it works!!!

#svn tutorial: didn't expect this here did you?

  svnadmin create project
  #create new svn controlled folder

  svn checkout https://subversion.assembla.com/svn/cirosantillitest/
  #clone

  svn checkout -r 3 file:///home/user/svn project
  #clone version number 3
  #everything you commit increases this number

  svn import nonsvn svn
  #take a non svn file directory and convert it to svn controlled one

  svn commit -m 'commit message'
  #commit. if your ssh is added, this pushes to the original repository!!!
  #this is why in svn everything happens over the network!!

  svn log
  #history of commits

  svn status
  #what is commited, changed and tracked

  svn mkdir foo -m 'commit message'
  #must use to make dirs, -m to commit with message

  svn rmdir foo -m 'commit message'
  #must use to remove dirs, m to commit with message

  svn add
  #add to version controll

  #get single file from repo, modify it, and up again!
    svn co https://subversion.assembla.com/svn/cirosantillitest/ . --depth empty
    svn checkout readme.textile
    vim readme.textile
    svn ci -m 'modified readme.textile'
