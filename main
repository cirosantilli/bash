#!/usr/bin/env bash

set -eu

# Main bash language cheatsheet.

#sources

    #<http://tldp.org/LDP/abs/html/abs-guide.html>

#POSIX

    # If you aim at portability, watch out not to rely on non POSIX features!

    # Utilities in general will not be described here, only:

    # - language features:
    # - POSIX extensions to utilities that have a built-in implementation

##comments

        echo #

    # Escape comment:

        echo \#

##help

    # Prints help on a built-in commands.

    # Bash extension.

    # Bash built-in

    # View all built-in commands:

        help

    # Get help on an specific command:

        help help
        help for

##spaces

    # more than one tabs or spaces are useless like in c

    # `;` can be used to separate commands much like in c:

        echo a; echo b

    # Unlike C, newlines at the end od a command imply `;`:

        echo a
        echo b

    # So you can't use newlines at will as you can in C

        function init_test {
                wd="`pwd`"
                tmp="`mktemp -d`"
                cd $tmp
        }

        function cleanup_test {
                cd "$wd"
                rm -r "$tmp"
        }

#execute outside path

        echo "echo a" > a
        chmod 777 a
        ./a
        #a
        `realpath a`
        #a

##variables

        a="abc"
        assert [ $a = abc ]

        a="abc"
        assert [ "0${a}1" = "0abc1" ]

    ##you can use vars as commands

            a="echo b"
            $a
            #b
        #assert [ `$a` = b ]
        #assert [ $(a) = b ]
        #assert [ "$a"   = "echo b" ]

    ##vars are not expand recursivelly

            b=c
            a='$b'
            assert [ "$a" = '$b' ]
            a="$b"
            assert [ "$a" = c ]

    ##unset

            a=b
            unset a
            assert [ -z "`echo $a`" ]

    ##readonly

            readon=b
            readonly readon
        #readon=c
            #error: a is readonly

        #TODO how to undo readonly?

    ##special vars

        ##$0

            #path of cur scrip relative to cd

                echo '#!/bin/bash
        echo "$0"' > a
                chmod +x a
                ./a
                #./a

                DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
                #for the full path

        ##$1

                echo '#!/bin/bash
        echo "$1"
        echo "$2"' > a
            ./a a b
            #a
            #b

        ##$#

            #number of cli args

                echo '#!/bin/bash
echo "$#"' > a
                ./a a b
                #2
                ./a a b c d
                #4

            #usage

                #safe opt arg getting with shift

                    if [ $# -gt 0 ]; then
                        arg1="$1"
                        #argument 1
                        shift
                        #destroy arg 1
                    fi

                    if [ $# -gt 0 ]; then
                        arg2="$1"
                        #argument 2
                        shift
                        #destroy arg 2
                    fi

        ##$*

                DJVU_PATH="$*"
                #List of all arguments separated by SPACES.
                #Each argument is NOT quoted individually.

        ##$@

                DJVU_PATH="$@"
                #List of all arguments separated by SPACES.
                #Each argument IS quoted individually.

        #$?

            #exit status of last program run

                if false; then :; fi
                echo $?
                #0
                if true; then :; fi
                echo $?
                #1

        ##$$

            #PID of current process

                echo $$

        ##PPID

            #id of parent process
            #linux processes contain this info

                echo $PPID

        ##LINENO

            #cur line number!

                echo $LINENO

##variable substitution ##parameter expansion ##${}

    # Replace a variable by its value.

        a="printf b"
        assert [ $($a) = b ]

    # Inside double quotes, variable substitution can happen.

        a=b
        b="$a"
        assert [ $b = b ]

        a=b
        b="${a}c"
        assert [ $b = bc ]

    # Cannot happens inside single quoted strings.

    # Escape:

        a=b
        assert [ "\$a" = '$a' ]

    # Single dollars become literal dolars:

        assert [ "$"  = "\$" ]
        assert [ "$ " = "\$ " ]

    # But I woud not rely on such obscure behaviour.

    # String length:

        s='abcd'
        assert [ ${#s} -eq 4 ]

    # Substrings:

        s='abcd'
        assert [ ${s:0:1}   = a   ]
        assert [ ${s:1:1}   = b   ]
        assert [ ${s:0:2}   = ab  ]
        assert [ ${s:2}     = cd  ]

    # You can do certain glob operations on strings:

        s='12223'

    # Remove shortest matching preffix:

        assert [ ${s#1*2} = 223 ]

    # Uses pattern matching notation to replace.

    # Mnemonic: `#` (under 3) comes before `%` (under 5),
    # so it is the prefix, and not suffix

    # Remove longest matching preffix

        assert [ ${s##1*2} = 3 ]

    # Mnemonic: two `##` is for long, one `#` is for short

    # Remove shortest matching suffix:

        assert [ ${s%2*3} = 122 ]

    # Remove shortest matching suffix:

        assert [ ${s%%2*3} = 1 ]

    ##applications

        # Get file extension or path without the extension:

            s='a/b.ext'
            assert [ ${s%.*} = a/b ]
            assert [ ${s##*.} = ext ]

##quoting

    ##double quotes

        # Space to var:

            a="a b"
            assert [ "$a" = "a b" ]

        # Command substitution is done inside them:

            assert [ "`printf a`" = a ]

        ##backslash escapes

            # Backslash is not interpreted on literals.

            # `printf` does interpret them.

            # What `echo` does with them is POSIX undefined behaviour.

                assert [ ! "$(printf "a\nb")" = "a\nb" ]

            # Backslash interpretation can also be achieved by using the dollar single quote extension.

        ##multiline literals

            # Multiline literals include newlines by default:

                assert [ "$(echo "a
b")" = "$(printf "a\nb" )" ]

            # To avoid adding newlines at multiline literals, use a backslash `\`:

                assert [ "$(echo "a\
b")" = ab ]

        ##heredoc

            # Set stdin of command from a string.

            # Interprets variable expansion and command expansion in its interior like `""` quoted strings.

                assert [ "$(cat <<ANYTHING
`printf a`
ANYTHING
)" = a ]

            # A common values for anything is `EOF`.

            # This is a great combo to create files with fixed content:

                cat <<EOF > filename
content
EOF

        # One line heredoc:

            assert [ "$(cat <<< "a")" = a ]

    ##single quotes

        # Does not do variable expansion nor command expansion.

            a=b
            b='$a'
            assert [ "$b" = '$a' ]

        # Newlines are not ignored on multiline literals.

            echo 'a\
b'

        # Produces $'a\\\nb'

    ##dollar single quote ##$''

        # Interprets backslash.

        # Does not do

        # Backquote assumed

            a=$'a\nb'
            assert [ "$a" = `echo -e "a\nb"` ]
            #not "$'a\nb'" = ...

        # Cannot be quoted

            assert [ "$'a'" = "'\$a'" ]

        # Cannote be nested:

            #a=`echo `echo a``

        # Because both characters are equal, there is no opening and closing like parenthesis.

        # See `$(` for a solution.

        # Trailing newlines are all removed!:

            assert [ a`printf "\n\n"` = a ]

##parenthesis ##() ##command groups

    # Formal name: command group.

    # Spawn subshell and exec command in it.

    # Change current dir, prints previous dir:

        cd; pwd

    # Does not  change current dir and prints home dir:

        ( cd; pwd )

    # Equivalent to

        bash -c 'cd; pwd'

    # EXCEPT you don't have to do escaping or quoting!

##subshell

    # Good soure: <http://www.linuxtopia.org/online_books/advanced_bash_scripting_guide/subshells.html>

    # Many bash operations are run inside subshells.

    ##create subshells

        # Operations that create subshells:

        # - command groups:

                ( echo a )

            #Commands inside braces do not generate subshells.

        # - both sides of pipes run on subshells:

            a=0
            echo a | a=1
            [ $a = 0 ] || exit 1

            a=0
            a=1 | echo
            [ $a = 0 ] || exit 1

        # - for and whil do *not* create a subshell:

            a=0
            for i in 0 1; do
                a=$i
            done
            [ $a = 1 ] || exit 1

            a=0
            while read l; do
                a=$l
            done < <( printf "0\n1\n" )
            [ $a = 1 ] || exit 1

    ##properties of subshells

        # Unexported variables carry over:

            a=0
            [ `( echo $a )` = 0 ] || exit 1

        # Assignments do not affect parent:

            a=0
            ( a=1 )
            [ $a = 0 ] || exit 1

        # Directory changes do not affect parent:

            cd
            ( cd .. )
            [ "$(pwd)" = "$HOME" ] || exit 1

        # Subshell output can be piped:

            [ $( ( printf a; printf b ) | cat ) = ab ] || exit 1

        # Subshell input for the first command can come from a pipe:

            [ $( echo a | ( cat; cat ) ) = a ] || exit 1

        # PID may TODO0 must? be the same as parent:

            [ `echo $$` = `( echo $$ )` ] || echo different

    ##subshell vs shell inside shell

        # A subshell is different from a shell launched inside a shell.

        # For example, subshells inherit variables from parent even it they were not exported:

            a=0
            [ `( echo $a )` = 0 ] || exit 1

        # But a shell inside a shell does not unless they are exported:

            a=0
            bash
            [ -z $a ] || exit 1
            exit 0

            a=0
            bash
            [ -z $a ] || exit 1
            exit 0

##braces ##{} ##inline group

    # Formal name: inline group.

    # Excutes in current context.

        a=0
        b=1
        { printf $a; printf $b; } | cat

    # Prints `01`.

    # Does not spawn a subshell.

##command substitution ##`` ##$()

    #<http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_03>

    ##backquote

        # Same as <#eval expression>

            assert [ `echo a` = a ]

        # External double quote not assumed.

            assert [ ! `echo "a b"`  = "a b" ]
            assert [ "`echo "a b"`" = "a b" ]

        # Inner double or single quotes are fine:

            assert [ "`echo "a b"`" = "a b" ]
            assert [ "`echo 'a b'`" = "a b" ]

        # Inner backquotes are not fine:

            #`echo `echo a``

        # This is why `$()` is better: you can nest it because it has an open/close pair:

            #$( echo $( echo a ))

        # Therfore consider always using `$()`.

    #$()

        # Similar to backquote:

            assert [ "$(echo abc)" = "abc" ]
            assert [ "`echo abc`"  = "abc" ]

        # Better than backquote because it can be nested:

            assert [ "$(echo $(echo a))" = "a" ]

        # Trailing newlines **are removed**!:

            assert [ a"$(printf "\n\n")" = "a" ]

##process substitution

    # bash extension.

    # Expands a line of the type `<(echo a)` to either a FIFO or a `/dev/fd`
    # open file descriptor that contains whatever was echoed.

    # Typical application: pass variables as file contents to utilities
    # that expect files.

        echo "Process substitution:"
        A="file content"
        echo <(echo "$A")
            # Possible output:
            #/dev/fd/63
        assert [ "$(cat < <(echo "$A"))" = "$A" ]

##history expansion ##! ##exclamation mark

    # Expands to the last command that starts with string.

    # Also expands inside double quotes! but not inside single quotes.

    # Controlled by the `H` option. Turned on by default on interactive shells.

        set -H
        echo a
        !e
        # Shell shows:
        # echo a
        # Output:
        # a
        [ "!e" = "echo a" ] || exit 1

    # The substitution happens early and insanely: it even affects what will go into history.

        echo a
        echo !e
        #echo echo a
        echo !e
        #echo echo echo a

    # TODO why the following expands: http://stackoverflow.com/questions/22125658/escape-history-expansion-exclamation-mark-inside-command-substitution

        echo a
        echo "$(echo '!e')"

##string

    ##interpret scapes sequences

        #`$'` strings interpret backslash escapes:

            a=b
            echo $'$a\nb'

        #but `$` is not interpreted as a variable

        #double quote analogue does not exist:

            a=b
            #echo $"a\nb"

        #solution: use `echo -e`:

            a=b
            echo -e "$a\nb"

    #null charcter shorthand:

        assert [ '' = $'\0' ]

    # Many string operations such as length and basic pattern matching notation
    # operations can be achieved via parameter expansion.

##expansion

    ##pathname expansion ##globbing

        # Formal name: #<pathname expansion>

        # Bash expands certain sequences to filenames before issuing commands.

        #  Nonhidden files cur dir (if there is at least one non-hidden file):

            echo *

        # Expansion only happens if there is at least one match.
        # If not, the original sequence is used.

            mkdir empty
            cd empty
            assert [ `printf *` = '*' ]

        # Hidden in files cur dir. Includes the annoying `.` and `..`:

            echo .*

        ##list all files in cur dir except `.` and `..` ##GLOBIGNORE

            # <http://stackoverflow.com/questions/2910049/how-to-use-the-wildcard-in-bash-but-exclude-the-parent-directory>
            # <http://unix.stackexchange.com/questions/1168/how-to-glob-every-hidden-file-except-current-and-parent-directory>

            # The problem is that `.*` includes `.` and `..`, and `..?*` becomes literal if no files match it.

            # I am yet to find a satisfactory POSIX commpliant way to do this.

            ##globignore

                # The best bash extension way without subshell is:

                    GLOBIGNORE_OLD=".:.."
                    GLOBIGNORE=".:.."
                    echo .*
                    GLOBIGNORE="$GLOBIGNORE_OLD"

                # The following *does not work* TODO why:

                    env GLOBIGNORE=".:.." echo *

                # With subshell:

                    (GLOBIGNORE=".:.."; echo .*)

                # The following *does not work* TODO why:

                    env GLOBIGNORE=".:.." bash -c 'echo .*'

            ##dotglob

                # Works for this case, but only if we also want the non hidden files.

                # Harder to properly restore state than `GLOBIGNORE`:

                    OPT="nullglob"
                    shopt -u | grep -q "$OPT" && changed=true && shopt -s "$OPT"
                    echo *
                    [ $changed ] && shopt -u "$OPT"; unset changed

            ##nullglob

                # Harder to properly restore state than `GLOBIGNORE` and longer than dotglob, so not useful:

                    OPT="nullglob"
                    shopt -u | grep -q "$OPT" && changed=true && shopt -s "$OPT"
                    echo * .[^.]* ..?*
                    [ $changed ] && shopt -u "$OPT"; unset changed

                # nullglob is required because ..?* expands to a literal otherwise.

            #- `ls -A` is good to view, but not usable programmatically if filenames have spaces.

        # Escape:

            echo '*'
            echo "*"

        # Start with a:

            echo a*

        # Second letter a:

            echo ?a*

        # * matches "".

        # Start with a or b:

            echo [ab]*

        # Start with 0, 1 or 2.

            echo [0-2]*

        # Works with vars:

            a=b
            "$a"*

        # Shows all the files that start with b

        # Only nonhidden:

        ##combos

            # For loop in cur dir:

                for f in .* *; do echo "$f"; done

        ##extended globbing

            #glob with ERE-like expressions instead of BREs

            #activate:

                shopt -s extglob

            #glob              ERE mnemonic
            #?(pattern-list)   (...|...)?
            #*(pattern-list)   (...|...)*
            #+(pattern-list)   (...|...)+
            #@(pattern-list)   (...|...)    [@ not a RE syntax]
            #!(pattern-list)   "!" used as for negative assertions in RE syntax

    ##tilde expansion

            assert [ "`sudo -u a echo ~`"  = /home/a ]
            assert [ "`echo ~a`" = /home/a ]
            assert [ "`echo ~root`" = /root ]
            assert [ "`echo ~homeless`" = '~homeless' ]

        #escape:

            assert [ "`echo "~a"`" = "~a" ]

        #*obvioustly* this does not work from scripts since scripts can be run as any user

    ##brace expansion

        #{}

        # Quite useful.

        ##alternatives

                assert [ "`for a in 0{ab,cd}1; do echo -n "$a "; done`" = $'0ab1 0cd1 ' ]

            #nested is ok:

                assert [ "`for a in 0{a,{b,c}}1; do echo -n "$a "; done`" = $'0a1 0b1 0c1 ' ]

        ##number ranges

                assert [ "`for a in a{1..3}b; do echo -n "$a"; done`" = $'a1b a2b a3b ' ]
                assert [ "`for a in a{-1..-3}b; do echo "$a"; done`" = $'a-1b\na-2b\na-3b' ]
                assert [ "`for a in a{1..5..2}b; do echo "$a"; done`" = $'a1b\na3b\na5b' ]
                assert [ "`for a in a{5..1..2}b; do echo "$a"; done`" = $'a5b\na3b\na1b' ]

        ##letter ranges

                assert [ "`for a in 0{a..c}1; do echo "$a"; done`" = $'0a1\n0b1\n0c1' ]
                assert [ "`for a in 0{a..e..2}1; do echo "$a"; done`" = $'0a1\n0c1\n0e1' ]

        #escape:

            echo "{1..3}"

        #applications:

            for i in {1..5}; do echo $i; done

            mkdir very/long/path/{a,b}

            cp a{,.bak}

##list

    #declare all:

        a=()
        a=( a b c "d d" )

    #cannot nest:

        #a=( (b) (c) )

    #declare elements:

        a[10]=b
        a[20]=c

    #cannot nest:

        #a[0]=(1 2)

    #concat:

        a+=( "e e" )

    #access:

        a[0]=1
        a[1]=2
        a[2]=3
        assert [ ${a[0]} = 1 ]
        assert [ ${a[1]} = 2 ]
        assert [ ${a[2]} = 3 ]

    #`{}` is obligatory here

    #loop:

        is=( a b "a b" )
        for i in "${is[@]}"; do echo $i; done
        #a
        #b
        #a b

        for i in "${a[@]}"; do echo $i; done
        #four lines. @ with quotes "" expands similary to "$@"
        #quotes for each element are actually put on the terminal

    #range:

        echo ${a[@]:1}

        echo ${a[@]:1:2}

##map ##associative array

        declare -A aa
        aa=([a]=1 [b]=2)
        assert [ ${aa[a]} = 1 ]
        assert [ ${aa[b]} = 2 ]

##string

    #equality:

        assert [ abc = abc ]

    #glo boes not work:

        assert [ ! abc = a*c ]

    #check empty:

        assert [ -z "" ]
        assert [ ! -z "a" ]

    ##double square brackets

        #glob works:

            assert [[ abcd == a*d ]]
            assert [[ abc == a?c ]]
            assert [[ abc == a[bB]c ]]

        #cannot quote right:

            assert [[ abcd != "a*d" ]]

##true ##false

    #false it is a program that does one thing: ``exit(1);`` !

    #very useful with bash

        which true

        assert [ `if true; then echo a; fi` = a ]
        assert [ -z `if false; then echo a; fi` ]

        v=true
        assert [ `if $v; then echo a; fi` = a ]

##square brackets

    #bash built-in

    #does the same as [test]

        [ 1 = 1 ]
        [ $? = 0 ]
        if [ 1 = 1 ]; then echo true; fi
        if [ ! 1 = 1 ]; then echo true; fi

    #integer

            assert [ 1 -eq 1 ]
            assert [ 1 -lt 2 ]
            assert [ 2 -gt 2 ]
            assert [ 1 -le 2 ]
            assert [ 2 -ge 2 ]

##arithmetic

    ##let

        # bash extension.

        # Compute and assign arigthmetic:

                let i=1+1
                let i=i+1
                [ $i -eq 3 ] || echo fail

        # This is the nicest way to do it i think.

        # NO SPACES ALLOWED! all fail:

            #let i =1+1
            #let i= 1+1
            #let i=1 +1

    ##double parenthesis ##((

        [ $(( 1+1 )) -eq 2 || echo fail

        (( 1>2 )) || echo fail

    ##extended logical test ##double square brackets ##[[

##boolean

    # && only execute next command if previous command gives status = 1
    # ||                                                            = 0

    # If they don't execute, status is unchanged.

    # Therefore, for if `&&` has the same effect as and and `||` the same effect as or.

        assert [ `true && echo a` = a ]
        assert [ -z `false && echo a` ]
        assert [ `false || echo a` = a ]
        assert [ -z `true || echo a` ]

        assert [ `if true && true; then echo a; fi` = a ]
        assert [ -z `if false && true; then echo a; fi` ]
        assert [ -z `if true && false; then echo a; fi` ]
        assert [ -z `if false && false; then echo a; fi` ]

        assert [ `if true || true; then echo a; fi` = a ]
        assert [ `if false || true; then echo a; fi` = a ]
        assert [ `if true || false; then echo a; fi` = a ]
        assert [ -z `if false || false; then echo a; fi` ]

##colon ##:

    # Do nothing statement:

        if true; then : ; fi

##case

    # Each case is a "pattern matching notation" pattern
    # or an pattern | pattern (not a feature in general "pattern matching notation").

        a=
        case $a in
            [a-c])
                echo "1"
            ;;
            [d-e]|[1-3])
                echo "2"
            ;;
            # There can be no spaces between `*` and the rest of the string!
            # Use quoting to avoid the spaces.
            "a "*)
                echo "a b"
            ;;
            *)
                echo "3"
            ;;
        esac

    #single line:

        a=
        case $a in a) echo "1" ;; *) echo "2" ;; esac

##if

        if false; then
            exit 1
        fi

    ##not ##! ##exclamation mark

        # `!` can be either:
        #
        # - part of the if statement
        # - part of the `test` command which is the same as bracket notation `[  ]`.

        # Part of the `if` statement:

            assert [ `if ! false; then echo a; fi` = a ]

##for while

        for f in a b; do echo "$f"; done
            #'a b'
        for f in 'a  b'; do echo "$f"; done
            #'a  b'

        echo {1..5..2}
            #'1 3 5'
        for i in {1..5..2}; do echo $i; done
            #$'1\n3\n5\n'

    # Break:

        i=0
        while [ $i -lt 10 ]; do
                echo $i
                let i=i+1
                if [ $i -eq 5 ]; then
                    break
                fi
        done

##function

    # Mandatory `;` on single line func:

        function f { echo $1; }

        function f
        {
            echo $1
        }

    # Unbound variable:

        #f

            assert [ "`f a`"    = $'a' ]
            assert [ "`f a b`"  = $'a' ]

    #ERROR:

        #function f { echo $1; }

    # Must have newlines.

##redirection

    # The following descriptors are always open by default:

    # - 0: stdin
    # - 1: stdout
    # - 2: stderr

    # Echo to stderr:

        echo "to stderr" 1>&2

    # Descriptor 3 to descriptor 4:

        echo a 3>&4

    # Descriptor 3 to file f:

        echo a 3>f

    # If input descrpitor is not given it defaults 1 (stdout). Decriptor 1 to file f:

        echo a >f

    # Descriptors 1 and 2 to file f:

        echo a &>f

    # Same as above but desincouraged by the manual since it breaks if file name is a number:

        echo a >&f

    # Append stdout to file:

        echo a >>"$f"

        function outerr {
            echo out
            echo err 1>&2
        }

        outerr
        #out
        #err

        outerr &>/dev/null
        #

        outerr >/dev/null
        #err

        outerr 2>/dev/null
        #out

    ##multiple redirections

        # The order of multiple redirections matters.

        # Think of them as variable assignments made from right to left.

            outerr >/dev/null 2>&1
            #

            outerr 2>&1 >/dev/null
            #err

    ##stdin redirection

        # Analogous to stdout redirection.

        # Get stdin of previous command from given file.

            printf abc >f
            assert [ $(cat <f) = abc ]

        # Combo combo with Process Substitution to pass a variable to stdin:

            assert [ $(cat < <(printf abc)) = abc ]

    ##| ##pipe

        # `a | b` connects stdout and stderr of `a` to stdin of `b`.

            assert [ "`outerr | cat`" = $'out\nerr' ]

        # Make a pipe take only stderr:

            outerr |& cat
            outerr >/dev/null | cat

    ##other fd

        # It is possible to create further file descriptors.

        # First, those descriptors must be made point somewhere,
        # or you get a `bad file descriptor error`:

            #echo a 1>&13

        # The usual way to use them is to redirect them to existing files or other
        # descriptors via the exec redirection combo.

        # From now on, redirect `3` to `1`:

            exec 3<&1

        # Echo to 3:

            echo 3 >&3

        # Close 3

            exec 3>&-

        # Open file `f` and assign fd 3 to it:

            exec 3<>f

        # Read the first line

            read <&3

        # Close `3`:

            exec 3>&-

    ##gotcha

        #YOU CANNOT MODIFY A FILE INLINE WITH REDIRECTION LIKE THIS:

            echo $'0\n1' > a
            grep 0 a | cat > a

        #this simply erases a

        #reason:

        #workaround: use sponge from moreutils.

##[]

    # Same interface as the `test` command.

##commands vs aliases vs built-ins vs keywords

    #- commands: programs in path. Ex: `ls`, `mkdir`

    #- aliases: declared with `alias a="b"`

        #subshells don't inherit aliases

        #one consequence of this is that they can only be run on interctive section,
        #not on scripts, which is exactly what they are inted to do!

    #- built-ins:

        #- hard coded in bash
        #- like commands
        #- examples:

            #cd, echo, let

        #good way to find that command is not a built-in:

                which cmd

        #if it has a path, then it is not a built-in

    #keywords:

        #- hard coded in bash
        #- not commands, but parts of commands
        #- examples: if, do, for, while, end*

    ##compgen

        #list all available commands / built-ins / functions / aliases,
        #in short, all "commands" you can issue from your shell

        #commands TODO

            #compgen -c

        #aliases

            #compgen -a

        #aliases and commands:

            #compgen -ac

        #built-ins

            #compgen -b

        #keywords

            #compgen -k

        #functions

            #compgen -A function

            #compgen -A function -abck #all above at once

    ##set

        # POSIX 7

        # View/modify vars, functions and SHELLOPTS.

        ##invocation

            # All of the set options options can be set from the command line invocation.

            # For example, it is the same to do:

                #bash -e a.sh

            # and to add:

                #set -e

            # To the top of `a.sh`.

            # There are however certain options which can only be used as command line arguments, such as `-c`.

        # List all vars and functions that are set:

            set

        # List only set options:

            echo $-

        # Sets the -e option:

            set -e

        # Unsets the -e option:

            set +e

            man bash
            #/SHELLOPTS

        # The `-+o` option allows to input long names.

        # Most, but not all, of the long names have short versions.

            echo a
            set -H
            !e
            set +H
            !e
            set -o histexpand
            !e
            set +o histexpand
            !e

        # View the values of all `-o` options:

            set -o

        # TODO: how to save and restore both single letter and `-o` options?

        ##set readline options

            # `set` can also be used to set readline options that determine how lines are read.

            # If lines are longer than screen, put then on a pager that allows you to navigate right / left with arrow keys.

                set horizontal-scroll-mode on

        ##most useful options

            ##e

                # Stop execution if one command returns != 0

                    set +e
                    false
                    set -e
                    # The following whould stop the execution of this script:
                    #false

                # It is recommended to add it to all scripts.

            ##u

                # Error on undefined variable:

                    set -u

                # It is recommended to add it to all scripts together with `-e`:

                    set -eu

            ##v

                # Print every string before it is executed.

                # Useful for debugging.

                # For exapmle:

                    a=b
                    set -v
                    echo $a

                # Outputs:

                    #echo $a       #stderr
                    #b             #stdout

            ##x

                # Print every string before it is executed with all expansions done.

                # Useful for debugging.

                # For exapmle:

                    a=b
                    set -x
                    echo $a

                # Outputs:

                    #+ echo b       #stderr
                    #b              #stdout

    ##shopt

        # Controls boolean options that determine how the shell behaves.

        # shopt vs set: <http://unix.stackexchange.com/questions/32409/set-and-shopt-why-two>
        # shopt is not POSIX, so it only contains bash extensions.

        # Show all options:

            shopt

        # Show one option:

            shopt dotglob

        # Set option:

            shopt -s op

        # Unset option:

            shopt -u op

        # Store shopt state for a single command: http://stackoverflow.com/questions/9126060/is-there-an-easy-way-to-set-nullglob-for-one-glob

            OPT="nullglob"
            shopt -u | grep -q "$OPT" && changed=true && shopt -s "$OPT"
            echo ..*
            [ $changed ] && shopt -u "$OPT"; unset changed

        ##invocation

            # All shopt options can be set from the command line invocation with `[-+]O <opt>`

            # For example:

                bash -O dotglob a.sh

            # Is the same as adding:

                shopt -s dotglob

            # to `a.sh`, and:

                bash +O dotglob a.sh

            # is the same as adding:

                shopt -u dotglob a.sh

    ##hash

        # The first time bash calls an executable,
        # it searches the path for it.

        # It then stores the basename -> path
        # in a hashmap, and only uses the hashmap from then on.

        # If the command changes location, bash does not search for it
        # again, and just gives an error.

            set -h
            mkdir d
            echo "echo 2" > d/echon
            chmod +x d/echon
            PATH="$PATH:`pwd`:`pwd`/d"
            assert [ `echon` = 2 ]
            for i in {}
            echo "echo 1" > echon
            chmod +x echon
            assert [ `echon` = 2 ]
            #surprise!
            rm -r d
            rm echon

            #./echon is first in path
            #and sould print 1!

            #with `set -h`
            #bash does not search the path every time
            #it would take too long
            #it remembers paths!

        # Show usage count of used commands:

            hash

        # Forget all paths:

            hash -r

        # Forget path for a single command:

            hash -d firefox


    ##type

        #Tell type of command (shell keyword, shell buit-in, alias, function or executable in path.

            type if
                #keyword

            type cd
                #builtin

            alias a cd
            type a
                #alias

            function f { echo f; }
            type f
                #function

            type mkdir
                #shows path

        #`-t`: machine readable output
        #`-P`: forces to search PATH for command. possible application: detect if program is installed and in path:

            if [ "`type -P vim`" = "" ]; then
                echo 'vim not installed'
            fi

##alias

        alias echo="echo a"
        assert [ `echo` = a ]
        assert [ `echo b` = "a b" ]

    ##command

        #run without alias:

            assert [ `command echo b` = b ]

    ##unalias

            unalias echo
            assert [ `command echo a` = a ]

    ##aliases are not exported

            alias a="echo a"
            assert [ `a` = a ]
            bash
            assert [ `a` = a ]
            #not found, unless you have another a!

##rc files

    #are files that are automatically sourced at login

    ##~/.profile

        #sourced when root bash starts

        #therefore environment variables here are visible on all shells

        #this is differnt from bashrc, where your variables are only defined for interactive shells

        #so if for example you want to start some application in the ubuntu dash (win + type name + enter)
        #and you want your application to see enviroment variables you set, you **must** set them from
        #`.profile` and not from `.bashrc`, since your program was started from a non-interactive shell

    #~/.bashrc

        #sourced when each interactive bash starts

    #~/.bash_logout

        #sourced just before bash ends

##login shell

    #login shells source

    #/etc/profile

        #sourced by all login shells of all users

    #~/.bash_profile, ~/.bash_login, and ~/.profile
        #the first one *and only* the first one that is found and readable
        #is sourced by login shells of the user

    ##how to make a login shell

        #start your system with it

            bash -l

        #this is not usually necessary since exported environment variables
        #are inherited by child shells

##interactive shell

    #normally: a shell with std(in|out|err) linket to console

    #sources ``/etc/bash.bashrc`` and ``~/.bashrc`` in that order
    #after any login sources

    ##non-interactive

        #- does not source the interactive files,
        #- sources "$BASH_ENV" file if not empty

        #Can be started via subshells.

    ##how to start interactive bash:

        #the one you start your system with

            bash
            #you are now inside and interactive bash!

##environment variables

    # It is not possible to set an environment variable for a single command:

        A=a
        [ "$(env A=b echo "$A")" = "a" ] || exit 1
        [ "$A" = "a" ] || exit 1

    ##magic

        # Some variables:

        # - are automatically set by bash to special values in addition to those inherited from parent
        # - control the behaviour of bash such as GLOBIGNORE

        # Some are readonly, others read write.

        # Commented list : <http://wikibash-hackers.org/syntax/shellvars>
        # also see man bash / shell variables.

        # Home dir. /home/ciro/ for me:

            echo $HOME

        # Cur username:

            echo $USER

        # cur hostname:

            echo $HOSTNAME

        # i686:

            echo $HOSTTYPE

            #x86_64

        # xterm on terminals run from x

            echo $TERM

        # Not sure what it means

            #linux on ctrl+alt+f1 terminal

        #cur working dir. ``pwd`

            echo $PWD

        # Last working dir. `pwd`

            echo $OLDPWD

        # Is printed on every terminal line:

            echo $PS1

        # May be very large due to coloring ansi coloring sequences.

        # Second line terminal. default '>' !

            echo $PS2

        # List of current on bash options

            echo $BASHOPTS

        # Readonly, modified indirectly by ``shopts``
        # on subshell startup, options in this list are set
        # ``man bash`` ``/shopts`` for full list

        # Similar to `BASHOPTS but set with ``set`` command instead:

            echo $SHELLOPTS

        # 4.2.37(1)-release

            echo $BASH_VERSION

        # Random number between 0 and 32767:

            echo $RANDOM
            echo $RANDOM

        # Seconds since shell started:

            echo $SECONDS
            echo $SECONDS

        # en_US.UTF-8:

            echo $LANG

        # Terminal width/height:

            echo $COLUMNS
            echo $LINES

        ##SHLVL

            #depth level of cur shell

                assert [ "`echo $SHLVL`" = 1 ]
                bash
                assert [ "`echo $SHLVL`" = 2 ]
                exit
                assert [ "`echo $SHLVL`" = 1 ]
                bash &
                assert [ "`echo $SHLVL`" = 1 ]
                #does not increase
                #only increases in nested bashes
                kill %+

##tab expansion

    # Bash in interactive mode uses tab for command completion.

    # `sh` does not implement this, so this is not required by POSIX.

    # For example, if you type:

        #ec

    # and then hit `<tab>`, you will get a list like:

        #echo      eclipse   econvert

    # If there is only one possible command, it expands automatically.

    # To avoid this and insert a literal tab, do `<c-v><tab>`, in analogy to the other
    # escape characters input.

##exec

    #POSIX 7.

    # Interface similar to an exec system call:
    # ends current shell and runs given command instead

    # Destroys the calling bash!

        assert [ $SHLVL = 1 ]
        exec bash
        assert [ $SHLVL = 1 ]

    ##exec and redirection

        # Redirect all followint stdout to file a:

            #exec >f
            #printf a

    ##application

        # Start a new bash with a custom environment.
        # and discard the old one

            exec env -i a=b c=d bash --norc --noprofile
            env
            exit

##history

    ##fc

        #posix 7

            echo a
            fc
            #opens "echo a" in vim for editing
            #when you quit, executes what you wrote

        #set default editor

                FCEDIT=/bin/vi
                fc

    ##ctrl-r

        #*very useful*

        #good tutorial: <http://ruslanspivak.com/2010/11/20/bash-history-reverse-intelligent-search/>

##clear

    # Clear terminal screen

            clear

##dirs stack

    # Move between dirs in stack.

    # Builtins, not in `sh`.

    # Show dir stack:

        dirs

    # -v : verbose. one per line, with line numbers:

        dirs -v

    # Push to dir stack

        pushd .

    # Pop from dir stack and cd to it

        popd

    # Very useful in when you need to cd somewherelse and come back later:

        pushd .
            cd d
            pwd
            pushd .
                cd d2
                pwd
            popd
        popd

echo '
ALL ASSERTS PASSED'
