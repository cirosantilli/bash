#!/usr/bin/env bash

#no complex programs shown: only language "basics"

#sources

  #<http://tldp.org/LDP/abs/html/abs-guide.html>

# bash shell follows POSIX standards
  #this includes common commands such as ``ls``, ``cd`` and many more
  #full list:
    #<http://pubs.opengroup.org/onlinepubs/9699919799/>

set -u # error on undefined variable1&>2
set -e # stop execution if one command return != 0

OUT="./_out/"
rm -fr "$OUT"
mkdir "$OUT"
cd "$OUT"

function assert {
  if [ ! $1 ]; then
    echo "assertion failed:"
    echo "$1"
    exit 1
  fi
}

assert '1 = 1'
assert '"a b" = "a b"'
assert "\"a b\" = \"a b\""
#assert "1 = 2"
  #ends program

#special vars

  #echo $1
    #ERROR
    #possibly unbound

  if [ $# -gt 0 ]; then
    arg1="$1"
      #argument 1
    shift
      #destroy arg 1
  fi

  if [ $# -gt 0 ]; then
    arg2="$1"
      #argument 2
    shift
      #destroy arg 2
  fi

  DJVU_PATH="$*"
    #List of all arguments separated by SPACES.
    #Each argument is NOT quoted individually. 

  DJVU_PATH="$@"
    #List of all arguments separated by SPACES.
    #Each argument IS quoted individually.

  current_process="$$"
    #returns current process name. Useful to create unique temporary files that have a recognizable component.

  TFILE="/tmp/$(basename $0).$$.tmp"
    #APPLICATION
    #create temp filename

  #$? exit status
    echo a | grep a
    echo $?
      #0
    echo a | grep b
    echo $?
      #1

echo variable

  a="abc"
  assert "$a = abc"

  a="abc"
  assert "0${a}1 = 0abc1"

  a="echo b"
  $a
    #b
  a='echo b'
  $a

#eval expression

  assert "$(echo abc) = abc"
  echo "`echo abc`"

echo string

  s='abcd'

  s1=$'\n'
  #newline to var

  s1=$'\0'
  #null to var

  echo ${#s}
    #4
      #string length
  echo ${s:0:1}
    #a
  echo ${s:1:1}
    #b
  echo ${s:0:2}
    #ab
  echo ${s:2}
    #cd

  #posix shell glob pattern ops
    s='abcd'
    echo ${s#pattern}
    echo ${s##pattern}
    echo ${s%pattern}
    echo ${s%%pattern}

  s='a/b.ext'
  echo ${s%.*}
    #a/b
      #simple remove ext

echo glob
  #simple regex like expanded before command is evaluated

  echo *
    #files cur dir
  echo '*'
    #literal
  echo a*
    #start with a
  echo ?a*
    #second letter a
    #* matches ""
  echo [ab]*
    #start with a or b
  whoami
    #ciro
  echo ~
    #/home/ciro
  echo ~test
    #/home/test
  echo ~root
    #/root
  echo ~idonthaveahome
    #~idonthaveahome
  

  for f in *; do echo "$f"; done
  for f in .*; do echo "$f"; done

echo array

  #declare
    a=()
    a=( a b c "d d" )

  a+=( "e e" )
    #append

  #access

  a[0]=1
  a[1]=2
  a[2]=3

  echo ${a[1]}
  echo ${a[2]}
  echo ${a[3]}
    #{} is obligatory here

  is=( a b "a b" )
  for i in "${is[@]}"; do echo $i; done
    #a
    #b
    #a b

  for i in "${a[@]}"; do echo $i; done
    #four lines. @ with quotes "" expands similary to "$@"
    #quotes for each element are actually put on the terminal

  echo ${a[@]:1}
    #subarray

  echo ${a[@]:1:2}
    #subarray: from 1, select 2

  #associative array
  declare -A aa
  aa=([hello]=world [ab]=cd)
  echo ${aa[hello]}
    #world
  echo ${aa[ab]}
    #cd

echo string

  if [ abc = abc ]; then echo true; fi
  if [ abc = a*c ]; then echo false; fi
    #no glob pattern

  if [[ abcd == a*d ]]; then echo true; fi
  if [[ abc == a?c ]]; then echo 'abc == a?c'; fi
  if [[ abc == a[bB]c ]]; then echo 'abc == a[bB]c'; fi
    #shell glob pattern

  if [[ abcd == "a*d" ]]; then echo false; fi 
    #don't quote right

  a=""
  if [ -z "$a" ]; then echo true; fi
  a="not empty"
  if [ -z "$a" ]; then echo true; fi

#if

  [ 1 = 1 ]
  [ $? = 0 ]
    #[ ] is an external program
    #it retunrs an exit status

  #[ 1 = 0 ]
    #program ends because of -e

  v=false
  v=true
  if $v; then
    echo "true"
  fi

  #integer

    if [ 1 -eq 1 ]; then echo true; fi
    if [ 1 -lt 2 ]; then echo true; fi
    if [ 2 -gt 2 ]; then echo true; fi
    if [ 1 -le 2 ]; then echo true; fi
    if [ 2 -ge 2 ]; then echo true; fi

  #logical

    a=true
    if [ ! a = b ]; then echo true; fi
      #not
    if [ a = a ] && [ b = b ]; then echo true; fi
      #and
    if [ a = b ] || [ b = b ]; then echo true; fi
      #or

echo for while

  for f in "a b"; do echo $f; done
    #a b
      #separtes at line sep

  for f in `ls -A`; do echo $f; done

  for i in `seq 1 10`; do echo $i; done

  i=0
  while [ $i -lt 10 ]; do
      echo $i
      let i=i+1 
  done

#arithmetic

  TWO=$(( 1+1 ))
  echo $TWO
    #obviously, bash was not made with this in mind, VERY cumbersome.
    #bash is all about strings and files, not numbers. 

  if (( 1>2 )); then echo '1>2'; fi

  #let
    let i=1+1
    let i=i+1
    echo $i
    #3

  #[[ ]] extended logical test

#functions

  function f {
    echo f $1
  }

  #f
    #unbound
  f a
    #f a
  f a b
    #f a

#redirection

  #0: stdin
  #1: stdout
  #2: stderr

  M=1
  N=2
  f=file
  echo a "$M">&"$N"
    #descriptor M to descriptor N
  echo a "$M">"$f"
    #descriptor M to file f
  echo a >&"$N"
  echo a >"$f"
    #defaults to descriptor 1 (stdout)
  echo a &>"$f"
    #descriptors 1 and 2
  echo a >>"$f"
    #append stdout to file

  #descriptors
    function outerr {
      echo out
      echo err 1>&2
    }

    outerr
      #out
      #err
    outerr &>/dev/null
      #
    outerr >/dev/null
      #err
    outerr 2>/dev/null
      #out
    outerr >/dev/null 2>&1
      #
      #writes stderr *and* stdout to /dev/null
      #- first redirects stderr to stdout
      #- then stdout to f
      #so they both go to f
      #rightmost comes first

  #< input

    cat <"$f"
      #file f to stdin
    cat < <(echo -e "a\nb\na b")
    echo -e "a\nb\na b" | cat 
      #echo to stdin

  #| pipe

    outerr | cat
      #out
      #err
        #pipes out *and* err
    outerr >/dev/null | cat
      #err

  #other fd
    exec 3<&1
      #create 3
      #write 3 to 1
    echo 3 >&3
      #1 to 3 to 1
    exec 3>&-
      #close 3

    exec 3<> "$f"
      #open f and assign fd 3 to it
    read <&3
      #read the first line
    exec 3>&-
      #close 3
    echo $REPLY

#background

  jobs
    #shows jobs running on background of cur bash
    #
    #%N	Job number [N]
    #%S	Invocation (command line) of job begins with string S
      #if several matches, ambiguous, and does nothing
    #%?S	Invocation (command line) of job contains within it string S
    #%%	"current" job (last job stopped in foreground or started in background)
    #%+	"current" job (last job stopped in foreground or started in background)
    #%-	Last job
    #$!	Last background process
    #
    #shows:
    #  jobspec : local id
    #  status : runnning, stopped, done
    #  invocation : exact program call, including command line args. Ex: ``ls ~``

  ls &
  sleep 100 &
  sleep 100 &
  sleep 100 &
    #runs on background
    #
    #[1] 12345678
    #means local id 1
    #process number 12345678
    #
    #when process ends, it prints ``[n] 1234`` and disappears
    #
    #stdout continues to go to cur terminal, even if in bg

  #firefox
    #Ctrl z
    #puts currently foreground running on background stopped

  #bg %3
    #starts running job 3 which was stopped on background
  #bg
  #bg %+
  #bg %%
    #last bg job [+]
  #bg %-
    #before last bg job [-]

  #fg %3
    #starts running job 3 which was on background on foreground
  #fg
    #last job

  #kill %1
    #kill subprocess [1]
  #kill $PID
    #kill by process id

  #wait && ls
    #wait for all bg jobs to finish
  #wait %3 && ls
    #job 3

  #vlc 100 &
  #vlc 100 &
  #vlc 100 &
  #disown %3
    #remove job 3 from list of sub jobs
    #closing bash will not kill it anymore


#list available commands
  #commands: programs in path
  #aliases: alias a="b"
    #can only be run on interctive section, not on scripts
  #built-ins: 
    #hard coded in bash
    #like commands
    #examples:
      #echo, printf, read
      #let, eval, set export
  #keywords: 
    #hard coded in bash
    #not commands, but parts of commands
      #if, do, for, while, end*
    #source:
      #http://tldp.org/LDP/abs/html/internal.html
  compgen -c #commands
  compgen -a #aliases
  compgen -ac #both
  compgen -b #built-ins
  compgen -k #keywords
  compgen -A function #functions
  compgen -A function -abck #all above at once
