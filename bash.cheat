#!/usr/bin/env bash

#------------------------------------------------------------
#
#Ciro D. Santilli
#
#bash commands/constucts that correspond to programming languages like c
#
#no complex programs shown
#
#------------------------------------------------------------

#logical operations
  if 0 -a 0; then
    echo true
  fi
  #logical 'and'. DO NOT PUT IT INSIDE [], or it becmoses file exists

#command line arguments
PDF_PATH="$1" #argument 1
DJVU_PATH="$2" #argument 2

  DJVU_PATH="$*"
  #List of all arguments separated by SPACES.
  #Each argument is NOT quoted individually. 

  DJVU_PATH="$@"
  #List of all arguments separated by SPACES.
  #Each argument IS quoted individually.

  CUR_PROCESS="$$"

#returns current process name. Useful to create unique temporary files that have a recognizable component.
TFILE="/tmp/$(basename $0).$$.tmp"

#variables
  PDF_PATH="$VAR_NAME"
  PDF_PATH="${VAR_NAME}"
  #acess the value of a variable

  PDF_PATH="${PATH_NOEXT}.pdf"
  #concatenate a variable and a string 

#strings
  STR='asdf'

  VAR=$'\n'
  #newline to var

  VAR=$'\0'
  #null to var

  echo ${#STR}
  #string length

  echo ${STR:2}
  #df
  #extract from char 2

  echo ${STR:1:2}
  #sd
  #extract 2 chars starting at 1

  echo ${STR:1:1}
  #'s'
  #get char at an index

  if [[ "$string" == *My* ]]
  then
    echo "It's there!";
  fi
  #test is a string contains POSIX expr

  ${V#pattern}
  #Delete the longest part of pattern that matches the beginning of variable 's value. Return the rest.

  ${V##pattern}
  #Delete the shortest part of pattern that matches the beginning of variable 's value. Return the rest.

  ${V%pattern}
  #Delete the longest part of pattern that matches the beginning of variable 's value. Return the rest.

  ${V%%pattern}
  #Delete the shortest part of pattern that matches the end of variable 's value.Return the rest.

  echo ${F%.*}
  #"$F" without extension

  #pattern is a POSIX regex, such as "*.?.*"

#$() evaluate an expression and paste output at position of '$'

  #this is how you return values from a function and put them into varibales

  VAR="$(find . -name '*.pdf')"
  echo "$VAR"

#arithmetic expression

  TWO=$(( 1+1 ))
  echo $TWO
  #obviously, bash was not made with this in mind, VERY cumbersome.
  #bash is all about strings and files, not numbers. 

#operators
  (( 1>2 ))
  #(( )) arithmetic test


  #[[ ]] extended logical test

  #data structures

  #array

    #declare
    array1=( itm1 itm2 itm3 "itm 4")

    array2[1]=itm1
    array2[2]=itm2
    array2[3]=itm3

    array2+=("itm 4")
    #append

    #access

    echo ${array1[1]}
    echo ${array1[2]}
    echo ${array1[3]}
    #the {} is obligatory here

    for i in ${array1[*]}; do echo $i; done
    for i in ${array1[@]}; do echo $i; done
    for i in "${array1[*]}"; do echo $i; done
    #one line. * with quotes "" expands similary to "$*"

    for i in "${array1[@]}"; do echo $i; done
    #four lines. @ with quotes "" expands similary to "$@"
    #quotes for each element are actually put on the terminal

    echo ${array[@]:1}
    #subarray

    echo ${array[@]:1:2}
    #subarray: from 1, select 2

    #associative array
    declare -A aa
    aa=([hello]=world [ab]=cd)
    echo ${aa[hello]}
    echo ${aa[cd]}

#flow control
  var=true
  if $var
  then
    echo "var is true"
  fi

#redirection
  #default file descriptors:
    #0: stdin
    #1: stdout
    #2: stderr

  echo a M>&N
    #descriptor M to descriptor N

  echo a >&N
    #same as 1>&N

    echo a 1>&2
      #echo to stderr

    echo a >&2
      #echo to stderr

  echo a M>"$F"
    #descriptor M F
    #OLD F IS DESTROYED!!!!!

    echo a 1>a.txt
      #echo to a.txt

  echo a M>>"$F"
    #append to F

    echo a 1>>a.txt
      #append "a" to a.txt

  echo a &>"$F"
    #stdout and stderr to F

  echo a &> /dev/null
    #stdout and stderr to null
    #ignores output

#*

  echo *
  #files in current dir

  for f in *; do echo "$f"; done

#background

  jobs
    #shows jobs running on background of cur bash
    #
    #%N	Job number [N]
    #%S	Invocation (command line) of job begins with string S
      #if several matches, ambiguous, and does nothing
    #%?S	Invocation (command line) of job contains within it string S
    #%%	"current" job (last job stopped in foreground or started in background)
    #%+	"current" job (last job stopped in foreground or started in background)
    #%-	Last job
    #$!	Last background process
    #
    #shows:
    #  jobspec : local id
    #  status : runnning, stopped, done
    #  invocation : exact program call, including command line args. Ex: ``ls ~``

  ls &
  sleep 100 &
  sleep 100 &
  sleep 100 &
    #runs on background
    #
    #[1] 12345678
    #means local id 1
    #process number 12345678
    #
    #when process ends, it prints ``[n] 1234`` and disappears
    #
    #stdout continues to go to cur terminal, even if in bg

  firefox
    #Ctrl z
    #puts currently foreground running on background stopped

  bg %3
    #starts running job 3 which was stopped on background
  bg
  bg %+
  bg %%
    #last bg job [+]
  bg %-
    #before last bg job [-]

  fg %3
    #starts running job 3 which was on background on foreground
  fg
    #last job

  kill %1
    #kill subprocess [1]
  kill $PID
    #kill by process id

  wait && ls
    #wait for all bg jobs to finish
  wait %3 && ls
    #job 3

  vlc 100 &
  vlc 100 &
  vlc 100 &
  disown %3
    #remove job 3 from list of sub jobs
    #closing bash will not kill it anymore
