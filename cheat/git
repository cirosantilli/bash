#!/usr/bin/env bash

#sources
  #http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging

  #description of a production/dev/hotfix branch model
    #http://nvie.com/posts/a-successful-git-branching-model/

  #update your cloned repo
    #http://bassistance.de/2010/06/25/git-fu-updating-your-github-fork/

  #survey of git branching models
    #http://stackoverflow.com/questions/2621610/what-git-branching-models-actually-work

#config
  #first of all steps: tell git who you are
  #others may see this on commits

  git config --global user.name "Ciro Duran Santilli"
  git config --global user.email "ciro.santilli@gmail.com"

#init
  #create a git repo with you existing code

  git init
  #starts a repository here

  git remote add github "git@github.com:cirosantilli/python.git"
  git remote add bitbucket "https://cirosantilli@bitbucket.org/cirosantilli/testrepo0.git"
  #allows to push and pull current repo git@github.com:cirosantilli/python.git repo.
  #this repo gets an alias github. see #1 push for details

#clone
  #get a git repo from somewhere, local or remote

  R=git@github.com:cirosantilli/bash.git
  git clone $R
  #copies files to your computer
  #automatically creates a remote location called origin
    #see remote for what that means

#remote
  #add remote sources to your git repo
  #note that when you clone something, it alreay has a origin remote,
  #so you usually only need this when doing the first push

  git remote add github https://github.com/cirosantilli/latex.git
  #create a remote branch at github called github

  git remote 
  #shows remote repo aliases without their real addresses

  git remote -v
  #shows remote repo aliases and their real addresses

  git remote show
  #view all names of remote branches

  git remote show $B
  #view detail of branch

  git remote rm github
  #remove the branch github (if you for isntance entered the bad url, you will have to first remove the old one before you can add the correct url)

#add files
  #if you don't add files, git won't see them 

  git add $F
  #add a file
    #on next commit it will be seen by git
    #if you do commit -a, git will check all files that have already been added
    #without -a, you have to add each time

  git add '*.txt'
  #RECURSIVE add

  ack --py f | xargs -I'{}' git add "{}" +
  #use ack f option to add lots of source files at once

#commit
  #commit is creating a version

  git status
  #see uncommited changes and untracked files

  git commit -a -v
  #-a: commits all files that have been modified or deleted
    #(if deleted they will stop being tracked for the future)
    #without this, you have to add files each time one by one
  #-v: opens vim in a commit diff log. you can either enter a commit message on the first line,
  #  or leave it blank and cancel comit. action is taken after you save ans quit :wq

  git commit -am 'commit message'
  #same as above, but commits directly with message commit message

#push
  #pushing is updating hte chages you made
  #it is better to add a remote

  R=git@github.com:cirosantilli/bash.git
  B=fli3h
  git push "$R" "$B"

  git push -u origin master
  git push
  #-u: git remembers last push
    #next time, no needto repeat params

#tags
  #are names to commits. usefull for versioning
  git tag "v1.3"
  git push --tags

#fetch
  #get changes from remote
  #*does not change* current repo
  #creates new remote/branch branches

  git remote add upstream git@github.com:cirosantilli/test.git
  git fetch upstream
  git branch -r
  #origin/master
  #upstream/master

#pull
  git pull origin master
  #takes changes from the origin repo to current repo
    #if there are conflicts, you will have to merge them

#move

  git mv "$OLD_PATH" "$NEW_PATH"
  #move OLD_PATH to NEW_PATH. if the new path already exists, nothing is done.
  #use -f to force overwrite

  git mv -f "$OLD_PATH" "$NEW_PATH"
  #if the new path exists, it is overwritten

  git mv -k "$OLD_PATH" "$NEW_PATH"
  #if moving would lead to an error (overwrite without -f or file not tracked), skip the move

#rm

  git rm "$PATH"
  #stop tracking file and permanently delete it on disk.
  #only works if the files has not been modified after last commit. If it has, you must use the -f option.
  #if the file exist but is not being tracked, nothing is done

  git rm --cached "$PATH"
  #stop tracking file, but keep source

  git rm -f "$PATH"
  #rm even if the file has been modified after last commit, thus possible resulting is loss of data
  #if the file is not being tracked, nothing is done

  git rm -r "$PATH"
  #recurse remove into directories

  git ls-files --deleted -z | xargs -0 git rm
  #removes only tracked files that were mannualy deleted.
  #this might be useful since if you try to remove an untracked file with git, nothing happens

  git rm '*.txt'
  #RECURSIVE remove

#time travel
  #1) you cannot revert history on remote branches without risking to destroy people's work!
    #must to a correcting commit. revert command for that
    #if you are sure you are the only one, push --force will do

  git log	#see hashes of versions
  git log -p $file #history for a given file
  git log --follow -p file #idem, but also goes back on renames

  #referring to commits
    #  master :
    #  start of hash (4,6 chars, such as 1ab4)
    #  HEAD: most recent
    #  HEAD^: before most recent
    #  HEAD^^: two before most recent
    #  HEAD~2: two before most recent
    #  tag: version tag, usually versions such as v.1.2.

  #diff
    
    git diff $C1 $C2
    #see differences between two commits

    git diff $C1 $C2 $F
    #on a single file

    git diff --cached "$F"
    #staged differences before commit.
      #only for files that have been ``git add``

    git diff HEAD "$F"
    #all differences between current state and last commit
      #no need to have added the files

  git checkout $hash #go back to given Hash and KEEP changes. new commits will start branches
  git checkout master #go back to last commit and lose uncommited changes on all files
  git checkout $hash #go back to hash (beginning of hash). lose uncommited
  git checkout $hash -- $file1 $file2

  #revert only those files
  #if they had different names/location back then, you must put the old names
  #  and they will be restored under the old names/location

  git reset --hard	#go back to last commit and lose all changes made afterwards
  git reset --hard $hash #go back to hashe's commit and lose all that comes after it

#branch and merge
  #branching is creating a separate path of developpement

  git branch
  #show branches. * before current

  git branch -r
  #shows branches from all remotes as remote/branch pairs

  git branch "$B"
  #create a branch

  git checkout "$B"
  #go to that branch

  git checkout -b "$B"
  #create a branch an go to it

  git branch -d "$B"
  #delete branch

  git checkout master
  git merge "$B"
  #merge master with another branch 
  #if auto merge is fine
    #master goes to new node created after merge
  #else
    git status
    #shows what was unmerged
      #needs merge
    #files get modified to contain trash merge markers
    git mergetool
    #open with a merging tool

#remove file completelly from repo
  #for example:
    #sensitive data
  UNAME=cirosantilli
  REPONAME=python
  REPOURL=https://github.com/$UNAME/$REPONAME.git
  RMFILE=

  git filter-branch --index-filter "git rm --cached --ignore-unmatch \"$RMFILE\"" --prune-empty -- --all
  git push github master --force

  #remove from local dir
  rm -rf .git/refs/original/
  git reflog expire --expire=now --all
  git gc --prune=now
  git gc --aggressive --prune=now
  #MAIL ALL COLABORATORS AN TELL THEM TO git rebase

#submodule

  #use outside repos inside you main repo,
  #if you modify the outside repo, it is easy to push it back to its origin by itself!
  #commands outside of the submodule (log, diff, etc) don't see what goes on inside it
  #commands inside it do!

  #add new submodule to project
    git submodule add git://github.com/chneukirchen/rack.git rack
    #add an external submodule to dir named rack

  #clone project with submodule:
    git clone git://github.com/schacon/myproject.git #submodule is empty
    git submodule init #create .gitmodule
    git submodule update #get module from server

  #remove

      vim .submodules
      #Delete the relevant section from the .gitmodules file.

      vim .git/config
      #Delete the relevant section from .git/config.

      rm --cached $path_to_submodule #(no trailing slash).

      rm -Rf .git/modules/$path_to_submodule

      git commit -am 'removed submodule'

      rm -rf $path_to_submodule

#github api v3 via curl

  USER=cirosantilli
  REPO=repo
  PASS=

  #get repo info (large)
    curl -i https://api.github.com/users/$USER/repos

  #create remote git repo

    curl -u "$USER" https://api.github.com/user/repos -d '{"name":"'$REPO'"}'
    git remote add github git@github.com:$USER/$REPO.git
    git push origin master

    #{
      #"name": "$REPO",
      #"description": "This is your first repo",
      #"homepage": "https://github.com",
      #"private": false,
      #"has_issues": true,
      #"has_wiki": true,
      #"has_downloads": true
    #}

  #delete repo
    curl -u "$USER" -X DELETE https://api.github.com/repos/$USER/$REPO
    #careful, it works!!!

#svn tutorial: didn't expect this here did you?

  svnadmin create project
  #create new svn controlled folder

  svn checkout https://subversion.assembla.com/svn/cirosantillitest/
  #clone

  svn checkout -r 3 file:///home/user/svn project
  #clone version number 3
  #everything you commit increases this number

  svn import nonsvn svn
  #take a non svn file directory and convert it to svn controlled one

  svn commit -m 'commit message'
  #commit. if your ssh is added, this pushes to the original repository!!!
  #this is why in svn everything happens over the network!!

  svn log
  #history of commits

  svn status
  #what is commited, changed and tracked

  svn mkdir foo -m 'commit message'
  #must use to make dirs, -m to commit with message

  svn rmdir foo -m 'commit message'
  #must use to remove dirs, m to commit with message

  svn add
  #add to version controll

  #get single file from repo, modify it, and up again!
    svn co https://subversion.assembla.com/svn/cirosantillitest/ . --depth empty
    svn checkout readme.textile
    vim readme.textile
    svn ci -m 'modified readme.textile'
