#!/usr/bin/env bash

#sources

    #<http://tldp.org/LDP/abs/html/abs-guide.html>

#POSIX

    #Bash is a POSIX compliant extension of sh, which is POSIX

    #This means that it must include:

    #- POSIX language features, which account for a large part of its language features.

    #- commands which can only be implemented as built-ins such as:

        #- cd
        #- read

    #- commands which could be implemented as separate binaries, but which bash chooses to implement as built-ins
        #such as:

        #- echo
        #- printf
        #- test

        #POSIX does not specify if commands must be built-ins or separate binaries in path.

        #It is possible that those commands also have a separate binary implementation in the path.

        #In that case, the built-in version will be used.

    #If you aim at portability, watch out not to rely on non POSIX features!

##comments

        echo #

    #escape comment:

        echo \#

##spaces

    #more than one tabs or spaces are useless like in c

    #`;` can be used to separate commands much like in c:

        echo a; echo b

    #unlike c, newlines have the same meaning as `;`:

        echo a
        echo b

    #so you can't use newlines at will as you can in c

set -u # error on undefined variable
set -e # stop execution if one command returns != 0

function init_test {
        wd="`pwd`"
        tmp="`mktemp -d`"
        cd $tmp
}

function cleanup_test {
        cd "$wd"
        rm -r "$tmp"
}

#execute outside path

        echo "echo a" > a
        chmod 777 a
        ./a
        #a
        `realpath a`
        #a

##variables

        a="abc"
        assert [ $a = abc ]

        a="abc"
        assert [ "0${a}1" = "0abc1" ]

    ##you can use vars as commands

            a="echo b"
            $a
            #b
        #assert [ `$a` = b ]
        #assert [ $(a) = b ]
        #assert [ "$a"   = "echo b" ]

    ##vars are not expand recursivelly

            b=c
            a='$b'
            assert [ "$a" = '$b' ]
            a="$b"
            assert [ "$a" = c ]

    ##unset

            a=b
            unset a
            assert [ -z "`echo $a`" ]

    ##readonly

            readon=b
            readonly readon
        #readon=c
            #error: a is readonly

        #TODO how to undo readonly?

    ##special vars

        ##$0

            #path of cur scrip relative to cd

                echo '#!/bin/bash
        echo "$0"' > a
                chmod +x a
                ./a
                #./a

                DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
                #for the full path

        ##$1

                echo '#!/bin/bash
        echo "$1"
        echo "$2"' > a
            ./a a b
            #a
            #b

        ##$#

            #number of cli args

                echo '#!/bin/bash
echo "$#"' > a
                ./a a b
                #2
                ./a a b c d
                #4

            #usage

                #safe opt arg getting with shift

                    if [ $# -gt 0 ]; then
                        arg1="$1"
                        #argument 1
                        shift
                        #destroy arg 1
                    fi

                    if [ $# -gt 0 ]; then
                        arg2="$1"
                        #argument 2
                        shift
                        #destroy arg 2
                    fi

        ##$*

                DJVU_PATH="$*"
                #List of all arguments separated by SPACES.
                #Each argument is NOT quoted individually.

        ##$@

                DJVU_PATH="$@"
                #List of all arguments separated by SPACES.
                #Each argument IS quoted individually.

        #$?

            #exit status of last program run

                if false; then :; fi
                echo $?
                #0
                if true; then :; fi
                echo $?
                #1

        ##$$

            #PID of current process

                echo $$

        ##PPID

            #id of parent process
            #linux processes contain this info

                echo $PPID

        ##LINENO

            #cur line number!

                echo $LINENO

##quoting

    ##double

        #space to var:

            a="a b"
            assert [ "$a" = "a b" ]

        #dollar interpreted

            a=b
            b="$a"
            assert [ $b = b ]

        #dollar backlash escaped

            a=b
            assert [ "\$a" = '$a' ]

        #single dollar ok

            assert [ "\$" = "$" ]

        #backslash not interpreted

            echo "a\nb"
            #ab

        #newline ignored:

            echo "a\
b"

        #produces "ab"

    ##single

        #dollar not interpreted:

            a=b
            b='$a'
            assert [ "$b" = '$a' ]

        #newline not ignored:

            echo 'a\
b'

        #produces $'a\\\nb'

    ##dollar single

        #interprets backslash

        #does not interpret dollars

        #backquote assumed

            a=$'a\nb'
            assert [ "$a" = `echo -e "a\nb"` ]
            #not "$'a\nb'" = ...

        #cannot be quoted

            assert [ "$'a'" = "'\$a'" ]

        #cannote be nested:

            #a=`echo `echo a``

        #because both characters are equal, there is no opening and closing like parenthesis.

        #See `$(` for a solution.

        #Trailing newlines are all removed!:

            assert [ a`printf "\n\n"` = a ]

##parenthesis ##() ##command groups

    #Formal name: command group.

    #Spawn subshell and exec command in it.

    #Change current dir, prints previous dir:

        cd; pwd

    #Does not  change current dir and prints home dir:

        ( cd; pwd )

    #Equivalent to

        bash -c 'cd; pwd'

    #EXCEPT you don't have to do escaping or quoting!

##subshell

    #Good soure: <http://www.linuxtopia.org/online_books/advanced_bash_scripting_guide/subshells.html>

    #Many bash operations are run inside subshells.

    ##create subshells

        #Operations that create subshells:

        #- command groups:

                ( echo a )

            #Commands inside braces do not generate subshells.

        #- both sides of pipes run on subshells:

            a=0
            echo a | a=1
            [ $a = 0 ] || exit 1

            a=0
            a=1 | echo
            [ $a = 0 ] || exit 1

        #- for and whil do *not* create a subshell:

            a=0
            for i in 0 1; do
                a=$i
            done
            [ $a = 1 ] || exit 1

            a=0
            while read l; do
                a=$l
            done < <( printf "0\n1\n" )
            [ $a = 1 ] || exit 1

    ##properties of subshells

        #Unexported variables carry over:

            a=0
            [ `( echo $a )` = 0 ] || exit 1

        #Assignments do not affect parent:

            a=0
            ( a=1 )
            [ $a = 0 ] || exit 1

        #Directory changes do not affect parent:

            cd
            ( cd .. )
            [ "$(pwd)" = "$HOME" ] || exit 1

        #Subshell output can be piped:

            [ $( ( printf a; printf b ) | cat ) = ab ] || exit 1

        #Subshell input for the first command can come from a pipe:

            [ $( echo a | ( cat; cat ) ) = a ] || exit 1

        #PID may TODO0 must? be the same as parent:

            [ `echo $$` = `( echo $$ )` ] || echo different

    ##subshell vs shell inside shell

        #A subshell is different from a shell launched inside a shell.

        #For example, subshells inherit variables from parent even it they were not exported:

            a=0
            [ `( echo $a )` = 0 ] || exit 1

        #But a shell inside a shell does not unless they are exported:

            a=0
            bash
            [ -z $a ] || exit 1
            exit 0

            a=0
            bash
            [ -z $a ] || exit 1
            exit 0

##braces ##{} ##inline group

    #Formal name: inline group.

    #Excutes in current context.

        a=0
        b=1
        { printf $a; printf $b; } | cat

    #Prints `01`.

    #Does not spawn a subshell.

##command substitution

    #<http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_03>

    ##backquote

        #same as <#eval expression>

            assert [ `echo a` = a ]

        #external double quote not assumed.

            assert [ ! `echo "a b"`  = "a b" ]
            assert [ "`echo "a b"`" = "a b" ]

        #inner double or single quotes are fine:

            assert [ "`echo "a b"`" = "a b" ]
            assert [ "`echo 'a b'`" = "a b" ]

        #inner backquotes are not fine:

            #`echo `echo a``

        #this is why `$()` is better: you can nest it because it has an open/close pair:

            #$( echo $( echo a ))

        #therfore consider always using `$()`

    #$()

        #Similar to backquote:

            assert [ "$(echo abc)" = "abc" ]
            assert [ "`echo abc`"  = "abc" ]

        #Better than backquote because it can be nested:

            assert [ "$(echo $(echo a))" = "a" ]

        #Trailing newlines **are removed**!:

            assert [ a"$(printf "\n\n")" = "a" ]

##eval

    #exec string in current bash
        eval "a=b"
        assert [ $a = b ]

    #concatenates arguments, space separated:
        assert [ `eval echo a` = a ]

    ##applications

        #make varname from var

            a=b
            eval "$a=c"
            assert [ $b = c ]

##string

    ##interpret scapes sequences

        #`$'` strings interpret backslash escapes:

            a=b
            echo $'$a\nb'

        #but `$` is not interpreted as a variable

        #double quote analogue does not exist:

            a=b
            #echo $"a\nb"

        #solution: use `echo -e`:

            a=b
            echo -e "$a\nb"

    #null charcter shorthand:

        assert [ '' = $'\0' ]

    #string length

        s='abcd'
        assert [ ${#s} -eq 4 ]

    #substrings:

        s='abcd'
        assert [ ${s:0:1}   = a   ]
        assert [ ${s:1:1}   = b   ]
        assert [ ${s:0:2}   = ab  ]
        assert [ ${s:2}     = cd  ]

    ##glob operations

        #you can do certain glob operations on strings

            s='12223'

        #remove shortest matching preffix

            assert [ ${s#1*2} = 223 ]

        #mnemonic: `#` (under 3) comes before `%` (under 5),
        #so it is the prefix, and not suffix

        #remove longest matching preffix

            assert [ ${s##1*2} = 3 ]

        #mnemonic: two `##` is for long, one `#` is for short

        #remove shortest matching suffix:

            assert [ ${s%2*3} = 122 ]

        #remove shortest matching suffix:

            assert [ ${s%%2*3} = 1 ]

        ##applications

            #get file extension or path without the extension:

                s='a/b.ext'
                assert [ ${s%.*} = a/b ]
                assert [ ${s##*.} = ext ]

##expansion

    ##pathname expansion ##globbing

        #formal name: #<pathname expansion>

        #simple regex like expanded before command is evaluated

        #nonhidden files cur dir:

            echo *

        #hidden files cur dir + `.` + `..`

            echo .*

        #hidden files cur dir except `.` and `..`: <http://stackoverflow.com/questions/2910049/how-to-use-the-wildcard-in-bash-but-exclude-the-parent-directory>

            echo .[^.]* ..?*

        #all files in cur dir except `.` and `..`: `ls -A` is the best POSIX option IMHO

            echo '*'
            echo "*"

        #start with a:

            echo a*

        #second letter a:

            echo ?a*

        #* matches "".

        #start with a or b:

            echo [ab]*

        #start with 0, 1 or 2.

            echo [0-2]*

        #works with vars:

            a=b
            "$a"*

        #shows all the files that start with b

        #only nonhidden:

        ##combos

            #for loop in cur dir:

                for f in .* *; do echo "$f"; done

        ##extended globbing

            #glob with ERE-like expressions instead of BREs

            #activate:

                shopt -s extglob

            #glob              ERE mnemonic
            #?(pattern-list)   (...|...)?
            #*(pattern-list)   (...|...)*
            #+(pattern-list)   (...|...)+
            #@(pattern-list)   (...|...)    [@ not a RE syntax]
            #!(pattern-list)   "!" used as for negative assertions in RE syntax

    ##tilde expansion

            assert [ "`sudo -u a echo ~`"  = /home/a ]
            assert [ "`echo ~a`" = /home/a ]
            assert [ "`echo ~root`" = /root ]
            assert [ "`echo ~homeless`" = '~homeless' ]

        #escape:

            assert [ "`echo "~a"`" = "~a" ]

        #*obvioustly* this does not work from scripts since scripts can be run as any user

    ##brace expansion

        #{}

        #quite useful

        ##alternatives

                assert [ "`for a in 0{ab,cd}1; do echo -n "$a "; done`" = $'0ab1 0cd1 ' ]

            #nested is ok:

                assert [ "`for a in 0{a,{b,c}}1; do echo -n "$a "; done`" = $'0a1 0b1 0c1 ' ]

        ##number ranges

                assert [ "`for a in a{1..3}b; do echo -n "$a"; done`" = $'a1b a2b a3b ' ]
                assert [ "`for a in a{-1..-3}b; do echo "$a"; done`" = $'a-1b\na-2b\na-3b' ]
                assert [ "`for a in a{1..5..2}b; do echo "$a"; done`" = $'a1b\na3b\na5b' ]
                assert [ "`for a in a{5..1..2}b; do echo "$a"; done`" = $'a5b\na3b\na1b' ]

        ##letter ranges

                assert [ "`for a in 0{a..c}1; do echo "$a"; done`" = $'0a1\n0b1\n0c1' ]
                assert [ "`for a in 0{a..e..2}1; do echo "$a"; done`" = $'0a1\n0c1\n0e1' ]

        #escape:

            echo "{1..3}"

        #applications:

            for i in {1..5}; do echo $i; done

            mkdir very/long/path/{a,b}

            cp a{,.bak}

##list

    #declare all:

        a=()
        a=( a b c "d d" )

    #cannot nest:

        #a=( (b) (c) )

    #declare elements:

        a[10]=b
        a[20]=c

    #cannot nest:

        #a[0]=(1 2)

    #concat:

        a+=( "e e" )

    #access:

        a[0]=1
        a[1]=2
        a[2]=3
        assert [ ${a[0]} = 1 ]
        assert [ ${a[1]} = 2 ]
        assert [ ${a[2]} = 3 ]

    #`{}` is obligatory here

    #loop:

        is=( a b "a b" )
        for i in "${is[@]}"; do echo $i; done
        #a
        #b
        #a b

        for i in "${a[@]}"; do echo $i; done
        #four lines. @ with quotes "" expands similary to "$@"
        #quotes for each element are actually put on the terminal

    #range:

        echo ${a[@]:1}

        echo ${a[@]:1:2}

##map ##associative array

        declare -A aa
        aa=([a]=1 [b]=2)
        assert [ ${aa[a]} = 1 ]
        assert [ ${aa[b]} = 2 ]

##string

    #equality:

        assert [ abc = abc ]

    #glo boes not work:

        assert [ ! abc = a*c ]

    #check empty:

        assert [ -z "" ]
        assert [ ! -z "a" ]

    ##double square brackets

        #glob works:

            assert [[ abcd == a*d ]]
            assert [[ abc == a?c ]]
            assert [[ abc == a[bB]c ]]

        #cannot quote right:

            assert [[ abcd != "a*d" ]]

##true ##false

    #false it is a program that does one thing: ``exit(1);`` !

    #very useful with bash

        which true

        assert [ `if true; then echo a; fi` = a ]
        assert [ -z `if false; then echo a; fi` ]

        v=true
        assert [ `if $v; then echo a; fi` = a ]

##square brackets

    #bash built-in

    #does the same as [test]

        [ 1 = 1 ]
        [ $? = 0 ]
        if [ 1 = 1 ]; then echo true; fi
        if [ ! 1 = 1 ]; then echo true; fi

    #integer

            assert [ 1 -eq 1 ]
            assert [ 1 -lt 2 ]
            assert [ 2 -gt 2 ]
            assert [ 1 -le 2 ]
            assert [ 2 -ge 2 ]

##arithmetic

    ##let

        #comput and assign arigthmetic

                let i=1+1
                let i=i+1
                [ $i -eq 3 ] || echo fail

        #this is the nicest way to do it i think

        #NO SPACES ALLOWED! all fail:

            #let i =1+1
            #let i= 1+1
            #let i=1 +1

    #double parenthesis

        [ $(( 1+1 )) -eq 2 || echo fail

        (( 1>2 )) || echo fail

    #double square brackets

        #aka #[[

        #aka #extended logical test

##boolean

    #&& only execute next command if previous command gives status = 1
    #||                                                            = 0

    #if they don't execute, status is unchanged

    #therefore, for if ``&&`` has the same effect as and and ``||`` the same effect as or!

        assert [ `true && echo a` = a ]
        assert [ -z `false && echo a` ]
        assert [ `false || echo a` = a ]
        assert [ -z `true || echo a` ]

        assert [ `if true && true; then echo a; fi` = a ]
        assert [ -z `if false && true; then echo a; fi` ]
        assert [ -z `if true && false; then echo a; fi` ]
        assert [ -z `if false && false; then echo a; fi` ]

        assert [ `if true || true; then echo a; fi` = a ]
        assert [ `if false || true; then echo a; fi` = a ]
        assert [ `if true || false; then echo a; fi` = a ]
        assert [ -z `if false || false; then echo a; fi` ]

##colon

    #do nothing

        if true; then : ; fi

##case

    #each case is a <#pathname expansion> pattern
    #or an pattern | pattern (not a feature in regular glob):

        a=
        case $a in
            [a-c])
                echo "1"
                ;;
            [d-e]|[1-3])
                echo "2"
                ;;
            *)
                echo "3"
                ;;
        esac

##if

    #either:

        if false; then
            echo fail
        fi

    #or:

        if false; then
            echo fail
        fi

    ##not

        #! can be part of the if

        #note that [test] also understands !

            assert [ `if ! false; then echo a; fi` = a ]

##for while

        for f in a b; do echo "$f"; done
            #'a b'
        for f in 'a  b'; do echo "$f"; done
            #'a  b'

        echo {1..5..2}
            #'1 3 5'
        for i in {1..5..2}; do echo $i; done
            #$'1\n3\n5\n'

        i=0
        while [ $i -lt 10 ]; do
                echo $i
                let i=i+1
                if [ $i -eq 5 ]; then
                    break
                fi
        done

##function

    #mandatory `;` on single line func:

        function f { echo $1; }

        function f
        {
            echo $1
        }

    #unbound variable:

        #f

        assert [ "`f a`"    = $'a' ]
        assert [ "`f a b`"  = $'a' ]

    #ERROR:

        #function f { echo $1; }

    #must have newlines.

#redirection

    #0: stdin
    #1: stdout
    #2: stderr

    #echo to stderr:

        echo "to stderr" 1>&2

        M=1
        N=2
        f=file

    #descriptor M to descriptor N

        echo a "$M">&"$N"

    #descriptor M to file f:

        echo a "$M">"$f"

    #defaults to descriptor 1 (stdout):

        echo a >&"$N"
        echo a >"$f"

    #descriptors 1 and 2:

        echo a &>"$f"

    #append stdout to file:

        echo a >>"$f"

    #descriptors

            function outerr {
                echo out
                echo err 1>&2
            }

            outerr
            #out
            #err
            outerr &>/dev/null
            #
            outerr >/dev/null
            #err
            outerr 2>/dev/null
            #out
            outerr >/dev/null 2>&1
            #
            #writes stderr *and* stdout to /dev/null
            #- first redirects stderr to stdout
            #- then stdout to f
            #so they both go to f
            #rightmost comes first

    ##< ##input

            cat <"$f"
            #file f to stdin
            cat < <(echo -e "a\nb\na b")
            echo -e "a\nb\na b" | cat
            #echo to stdin

    ##| ##pipe

            assert [ "`outerr | cat`" = $'out\nerr' ]
            #out
            #err
                #pipes out *and* err
            outerr |& cat
            outerr >/dev/null | cat
            #err

    ##other fd

            exec 3<&1
            #create 3
            #write 3 to 1
            echo 3 >&3
            #1 to 3 to 1
            exec 3>&-
            #close 3

        #open f and assign fd 3 to it

            exec 3<> "$f"

        #read the first line

            read <&3

        #close 3:

            exec 3>&-

            echo $REPLY

    ##gotcha

        #YOU CANNOT MODIFY A FILE INLINE WITH REDIRECTION LIKE THIS:

            echo $'0\n1' > a
            grep 0 a | cat > a

        #this simply erases a

        #reason:

        #workaround: use sponge from moreutils.

##test ##[]

    #Compare values and check files, answer on exit status.

    #Equivalent convenient shorthand form via squre brackets: `[ ]`

    #Can do tons of different tests.

    #May also exist as a separate binary implementation on certain systems,
    #but the built-in has precedence:

        which test

    ##string compare

            test a = a && echo a
            #a
            test a = b && echo a
            #

    ##integer compare

        #always use `-eq` family, never `=` family:

            assert [ 1 -eq 1 ]
            assert [ 1 -eq 01 ]
            assert [ 1 -lt 2 ]
            assert [ 2 -gt 2 ]
            assert [ 1 -le 2 ]
            assert [ 2 -ge 2 ]

    ##file ops

        ##-e

            #file exists

            #may be a symlink or directory

            #useful to avoid overwriting useful files

        ##-r

            #file exists and is readable

            #useful before taking input from a file, since just checking its exsitence
            #is not enough in that case

        ##-s

            #exists and has size > 0

                rm -rf a
                touch a
                assert test -f a

        ##-f

            #exists and is regular file (not a symlink or directory)

                init_test
                touch a
                assert test -f a
                cleanup_test

    ##logical

            test ! a = a        && assert false
            test a = a -a b = b && assert false
            test a = a -a a = b && assert false
            test a = a -o a = b && assert false
            test a = b -o a = b && assert false

##read

    #Reads from stdin and stores in shell variables.

    #Therefore, this *must* be a shell BUILTIN, since it modifies shell variables directly

    #POSIX 7.

    #Get string from user into variable `a`:

        #read a
        #echo "$a"

    #Cannot write with pipe into read because the pipe spawns a subshell,
    #which cannot modify a variable in its parent shell:
    #<http://stackoverflow.com/questions/13763942/bash-why-piping-input-to-read-only-works-when-fed-into-while-read-const>

        a=a
        echo b | read a         #`read a` is executed in a subshell!
        [ $a = a ] || exit 1

    #Creating a subshell does work however:

        echo abc | ( read b; [ $b = abc ] || exit 1 ) || echo fail

    #and so do while combos, which also create one subshell per loop body:

        while read l; do
            echo "$l"
        done < <( echo -e "a\nb\na b" )

    #Read from file descriptor linewise and assign to variable.

        ##applications

            #Read file linewise:

                #while read l; do
                #    echo "$l";
                #done < "$f"

            #Read stdout linewise:

                while read l; do
                    echo "$l"
                done < <( echo -e "a\nb\na b" )

            #Split into fields:

                #IFS_OLD="$IFS"
                #while IFS=' : ' read f1 f2
                #do
                #    echo "$f1 $f2"
                #done < <( echo -e "a : b\nc : d" )
                #IFS="$IFS_OLD"

    ##GNU extensions

        #-p print a prompt message:

            read -p "enter string: " s
            echo "you entered $s"

##exec

    #bash interface similar to an exec system call:
    #ends current shell and runs given command instead

    #destroys the calling bash!

        assert [ $SHLVL = 1 ]
        exec bash
        assert [ $SHLVL = 1 ]
    #exec bash
        #ls then exits bash!
        #you don't see anything

    ##application

        #start a new bash with a custom environment

        #and discard the old one

            exec env -i a=b c=d bash --norc --noprofile
            env
            exit

    ##jobs

        #shows:
        #- jobspec : a local job id
        #- status : runnning, stopped, done
        #- invocation : exact program call, including command line args. Ex: ``ls ~``

            jobs

        #show pids of background jobs:

            jobs -p

        ##jobspecs

            #local job id, found by using <#jobs>

            #certain commands such as ``kill``, ``fg`` them in addition to pids

            #they are:
            #- %N	Job number [N]
            #- %S	Invocation (command line) of job begins with string S
                #if several matches, ambiguous, and does nothing
            #- ?S	Invocation (command line) of job contains within it string S
            #- %%	"current" job (last job stopped in foreground or started in background)
            #- %+	"current" job (last job stopped in foreground or started in background)
            #- %-	last job

        ##$!

            #contains the pid of last background process

    #ls &
    #sleep 100 &
    #sleep 100 &
    #sleep 100 &
        #runs on background
        #
        #[1] 12345678
        #means local id 1
        #process number 12345678
        #
        #when process ends, it prints ``[n] 1234`` and disappears
        #
        #stdout continues to go to cur terminal, even if in bg

    #firefox
        #Ctrl z
        #puts currently foreground running on background stopped

    #bg %3
        #starts running job 3 which was stopped on background
    #bg
    #bg %+
    #bg %%
        #last bg job [+]
    #bg %-
        #before last bg job [-]

    #fg %3
        #starts running job 3 which was on background on foreground
    #fg
        #last job

    #kill %1
        #kill subprocess [1]
    #kill $PID
        #kill by process id

    #wait && ls
        #wait for all bg jobs to finish
    #wait %3 && ls
        #job 3

    #vlc 100 &
    #vlc 100 &
    #vlc 100 &
    #disown %3
        #remove job 3 from list of sub jobs
        #closing bash will not kill it anymore

##commands vs aliases vs built-ins vs keywords

    #- commands: programs in path. Ex: `ls`, `mkdir`

    #- aliases: declared with `alias a="b"`

        #subshells don't inherit aliases

        #one consequence of this is that they can only be run on interctive section,
        #not on scripts, which is exactly what they are inted to do!

    #- built-ins:

        #- hard coded in bash
        #- like commands
        #- examples:

            #cd, echo, let

        #good way to find that command is not a built-in:

                which cmd

        #if it has a path, then it is not a built-in

    #keywords:

        #- hard coded in bash
        #- not commands, but parts of commands
        #- examples: if, do, for, while, end*

    ##compgen

        #list all available commands / built-ins / functions / aliases,
        #in short, all "commands" you can issue from your shell

        #commands TODO

            #compgen -c

        #aliases

            #compgen -a

        #aliases and commands:

            #compgen -ac

        #built-ins

            #compgen -b

        #keywords

            #compgen -k

        #functions

            #compgen -A function

            #compgen -A function -abck #all above at once

    ##set

        #view/modify vars, functions and SHELLOPTS

        #list all vars and functions that are set

            set

        #sets the -e option:

            set -e

        #unsets the -e option:

            set +e

            man bash
            #/SHELLOPTS

    ##type

        #tell type of command (shell keyword, shell buit-in, alias, function or executable in path

            type if
                #keyword

            type cd
                #builtin

            alias a cd
            type a
                #alias

            function f { echo f; }
            type f
                #function

            type mkdir
                #shows path

        #`-t`: machine readable output
        #`-P`: forces to search PATH for command. possible application: detect if program is installed and in path:

            if [ "`type -P vim`" = "" ]; then
                echo 'vim not installed'
            fi

##alias

        alias echo="echo a"
        assert [ `echo` = a ]
        assert [ `echo b` = "a b" ]

    ##command

        #run without alias:

            assert [ `command echo b` = b ]

    ##unalias

            unalias echo
            assert [ `command echo a` = a ]

    ##aliases are not exported

            alias a="echo a"
            assert [ `a` = a ]
            bash
            assert [ `a` = a ]
            #not found, unless you have another a!

##rc files

    #are files that are automatically sourced at login

    ##~/.profile

        #sourced when root bash starts

        #therefore environment variables here are visible on all shells

        #this is differnt from bashrc, where your variables are only defined for interactive shells

        #so if for example you want to start some application in the ubuntu dash (win + type name + enter)
        #and you want your application to see enviroment variables you set, you **must** set them from
        #`.profile` and not from `.bashrc`, since your program was started from a non-interactive shell

    #~/.bashrc

        #sourced when each interactive bash starts

    #~/.bash_logout

        #sourced just before bash ends

##login shell

    #login shells source

    #/etc/profile

        #sourced by all login shells of all users

    #~/.bash_profile, ~/.bash_login, and ~/.profile
        #the first one *and only* the first one that is found and readable
        #is sourced by login shells of the user

    ##how to make a login shell

        #start your system with it

            bash -l

        #this is not usually necessary since exported environment variables
        #are inherited by child shells

##interactive shell

    #normally: a shell with std(in|out|err) linket to console

    #sources ``/etc/bash.bashrc`` and ``~/.bashrc`` in that order
    #after any login sources

    ##non-interactive

        #- does not source the interactive files,
        #- sources "$BASH_ENV" file if not empty

        #Can be started via subshells.

    ##how to start interactive bash:

        #the one you start your system with

            bash
            #you are now inside and interactive bash!

##environment variables

    #bash automatically sets lots of environment variables for its child processes.

    #commented list : <http://wikibash-hackers.org/syntax/shellvars>
    #also see man bash / shell variables.

    #home dir. /home/ciro/ for me:

        echo $HOME

    #cur username:

        echo $USER

    #cur hostname:

        echo $HOSTNAME

    #i686:

        echo $HOSTTYPE

        #x86_64

    #xterm on terminals run from x

        echo $TERM

    #not sure what it means

        #linux on ctrl+alt+f1 terminal

    #cur working dir. ``pwd``

        echo $PWD

    #last working dir. ``pwd``

        echo $OLDPWD

    #is printed on every terminal line:

        echo $PS1

    #may be very large due to coloring ansi coloring sequences.

    #second line terminal. default '>' !

        echo $PS2

    #list of current on bash options

        echo $BASHOPTS

    #readonly, modified indirectly by ``shopts``
    #on subshell startup, options in this list are set
    #``man bash`` ``/shopts`` for full list

    #similar to `BASHOPTS but set with ``set`` command instead:

        echo $SHELLOPTS

    #4.2.37(1)-release

        echo $BASH_VERSION

    #random number between 0 and 32767:

        echo $RANDOM
        echo $RANDOM

    #seconds since shell started:

        echo $SECONDS
        echo $SECONDS

    #en_US.UTF-8:

        echo $LANG

    #terminal width/height:

        echo $COLUMNS
        echo $LINES

    ##shlvl

        #depth level of cur shell

            assert [ "`echo $SHLVL`" = 1 ]
            bash
            assert [ "`echo $SHLVL`" = 2 ]
            exit
            assert [ "`echo $SHLVL`" = 1 ]
            bash &
            assert [ "`echo $SHLVL`" = 1 ]
            #does not increase
            #only increases in nested bashes
            kill %+

##history

    ##fc

        #posix 7

            echo a
            fc
            #opens "echo a" in vim for editing
            #when you quit, executes what you wrote

        #set default editor

                FCEDIT=/bin/vi
                fc

    ##ctrl-r

        #*very useful*

        #good tutorial: <http://ruslanspivak.com/2010/11/20/bash-history-reverse-intelligent-search/>

##clear

    #clear terminal screen

            clear

##shopt

    ##builtin

        #show all options:

            shopt

        #set option:

            shopt -s op

        #unset option:

            shopt -u op

    ##hash

            set -h
            mkdir d
            echo "echo 2" > d/echon
            chmod +x d/echon
            PATH="$PATH:`pwd`:`pwd`/d"
            assert [ `echon` = 2 ]
            for i in {}
            echo "echo 1" > echon
            chmod +x echon
            assert [ `echon` = 2 ]
            #surprise!
            rm -r d
            rm echon

            #./echon is first in path
            #and sould print 1!

            #with ``set -h``
            #bash does not search the path every time
            #it would take too long
            #it remembers paths!

        #shows used commands in current session
        #with usage count

            hash

##dirs stack

    #move between dirs in stack

    #builtins, not in `sh`

    #show dir stack

        dirs

    # -v : verbose. one per line, with line numbers:

        dirs -v

    #push to dir stack

        pushd .

    #pop fro dir stack and cd to it

        popd

    #very useful in when you need to cd somewherelse and come back later:

        pushd .
            cd d
            pwd
            pushd .
                cd d2
                pwd
            popd
        popd

echo '
ALL ASSERTS PASSED'
