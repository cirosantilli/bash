#!/usr/bin/env bash

set -u # error on undefined variable
set -e # stop execution if one command returns != 0

#sources

    #<http://tldp.org/LDP/abs/html/abs-guide.html>

#POSIX

    #If you aim at portability, watch out not to rely on non POSIX features!

    #Utilities in general will not be described here, only:

    #- language features:
    #- POSIX extensions to utilities that have a built-in implementation

##comments

        echo #

    #escape comment:

        echo \#

##help

    #Prints help on a built-in commands.

    #Bash extension.

    #Bash built-in

    #View all built-in commands:

        help

    #Get help on an specific command:

        help help
        help for

##spaces

    #more than one tabs or spaces are useless like in c

    #`;` can be used to separate commands much like in c:

        echo a; echo b

    #unlike c, newlines have the same meaning as `;`:

        echo a
        echo b

    #so you can't use newlines at will as you can in c

function init_test {
        wd="`pwd`"
        tmp="`mktemp -d`"
        cd $tmp
}

function cleanup_test {
        cd "$wd"
        rm -r "$tmp"
}

#execute outside path

        echo "echo a" > a
        chmod 777 a
        ./a
        #a
        `realpath a`
        #a

##variables

        a="abc"
        assert [ $a = abc ]

        a="abc"
        assert [ "0${a}1" = "0abc1" ]

    ##you can use vars as commands

            a="echo b"
            $a
            #b
        #assert [ `$a` = b ]
        #assert [ $(a) = b ]
        #assert [ "$a"   = "echo b" ]

    ##vars are not expand recursivelly

            b=c
            a='$b'
            assert [ "$a" = '$b' ]
            a="$b"
            assert [ "$a" = c ]

    ##unset

            a=b
            unset a
            assert [ -z "`echo $a`" ]

    ##readonly

            readon=b
            readonly readon
        #readon=c
            #error: a is readonly

        #TODO how to undo readonly?

    ##special vars

        ##$0

            #path of cur scrip relative to cd

                echo '#!/bin/bash
        echo "$0"' > a
                chmod +x a
                ./a
                #./a

                DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
                #for the full path

        ##$1

                echo '#!/bin/bash
        echo "$1"
        echo "$2"' > a
            ./a a b
            #a
            #b

        ##$#

            #number of cli args

                echo '#!/bin/bash
echo "$#"' > a
                ./a a b
                #2
                ./a a b c d
                #4

            #usage

                #safe opt arg getting with shift

                    if [ $# -gt 0 ]; then
                        arg1="$1"
                        #argument 1
                        shift
                        #destroy arg 1
                    fi

                    if [ $# -gt 0 ]; then
                        arg2="$1"
                        #argument 2
                        shift
                        #destroy arg 2
                    fi

        ##$*

                DJVU_PATH="$*"
                #List of all arguments separated by SPACES.
                #Each argument is NOT quoted individually.

        ##$@

                DJVU_PATH="$@"
                #List of all arguments separated by SPACES.
                #Each argument IS quoted individually.

        #$?

            #exit status of last program run

                if false; then :; fi
                echo $?
                #0
                if true; then :; fi
                echo $?
                #1

        ##$$

            #PID of current process

                echo $$

        ##PPID

            #id of parent process
            #linux processes contain this info

                echo $PPID

        ##LINENO

            #cur line number!

                echo $LINENO

##quoting

    ##double quotes

        # Space to var:

            a="a b"
            assert [ "$a" = "a b" ]

        # Command substitution is done inside them:

            assert [ "`printf a`" = a ]

        ##backslash escapes

            # Backslash is not interpreted on literals.

            # `printf` does interpret them.

            # What `echo` does with them is POSIX undefined behaviour.

                assert [ ! "$(printf "a\nb")" = "a\nb" ]

            # Backslash interpretation can also be achieved by using the dollar single quote extension.

        ##multiline literals

            # Multiline literals include newlines by default:

                assert [ "$(echo "a
b")" = "$(printf "a\nb" )" ]

            # To avoid adding newlines at multiline literals, use a backslash `\`:

                assert [ "$(echo "a\
b")" = ab ]

        ##heredoc

            # Set stdin of command from a string.

            # Interprets variable expansion and command expansion in its interior like `""` quoted strings.

                assert [ "$(cat <<ANYTHING
`printf a`
ANYTHING
)" = a ]

        # One line heredoc:

            assert [ "$(cat <<< "a")" = a ]

    ##single quotes

        # Does not do variable expansion nor command expansion.

            a=b
            b='$a'
            assert [ "$b" = '$a' ]

        # Newlines are not ignored on multiline literals.

            echo 'a\
b'

        # Produces $'a\\\nb'

    ##dollar single quote ##$''

        # Interprets backslash.

        # Does not do

        # Backquote assumed

            a=$'a\nb'
            assert [ "$a" = `echo -e "a\nb"` ]
            #not "$'a\nb'" = ...

        # Cannot be quoted

            assert [ "$'a'" = "'\$a'" ]

        # Cannote be nested:

            #a=`echo `echo a``

        # Because both characters are equal, there is no opening and closing like parenthesis.

        # See `$(` for a solution.

        # Trailing newlines are all removed!:

            assert [ a`printf "\n\n"` = a ]

##parenthesis ##() ##command groups

    # Formal name: command group.

    # Spawn subshell and exec command in it.

    # Change current dir, prints previous dir:

        cd; pwd

    # Does not  change current dir and prints home dir:

        ( cd; pwd )

    # Equivalent to

        bash -c 'cd; pwd'

    # EXCEPT you don't have to do escaping or quoting!

##subshell

    # Good soure: <http://www.linuxtopia.org/online_books/advanced_bash_scripting_guide/subshells.html>

    # Many bash operations are run inside subshells.

    ##create subshells

        # Operations that create subshells:

        # - command groups:

                ( echo a )

            #Commands inside braces do not generate subshells.

        # - both sides of pipes run on subshells:

            a=0
            echo a | a=1
            [ $a = 0 ] || exit 1

            a=0
            a=1 | echo
            [ $a = 0 ] || exit 1

        # - for and whil do *not* create a subshell:

            a=0
            for i in 0 1; do
                a=$i
            done
            [ $a = 1 ] || exit 1

            a=0
            while read l; do
                a=$l
            done < <( printf "0\n1\n" )
            [ $a = 1 ] || exit 1

    ##properties of subshells

        # Unexported variables carry over:

            a=0
            [ `( echo $a )` = 0 ] || exit 1

        # Assignments do not affect parent:

            a=0
            ( a=1 )
            [ $a = 0 ] || exit 1

        # Directory changes do not affect parent:

            cd
            ( cd .. )
            [ "$(pwd)" = "$HOME" ] || exit 1

        # Subshell output can be piped:

            [ $( ( printf a; printf b ) | cat ) = ab ] || exit 1

        # Subshell input for the first command can come from a pipe:

            [ $( echo a | ( cat; cat ) ) = a ] || exit 1

        # PID may TODO0 must? be the same as parent:

            [ `echo $$` = `( echo $$ )` ] || echo different

    ##subshell vs shell inside shell

        # A subshell is different from a shell launched inside a shell.

        # For example, subshells inherit variables from parent even it they were not exported:

            a=0
            [ `( echo $a )` = 0 ] || exit 1

        # But a shell inside a shell does not unless they are exported:

            a=0
            bash
            [ -z $a ] || exit 1
            exit 0

            a=0
            bash
            [ -z $a ] || exit 1
            exit 0

##braces ##{} ##inline group

    # Formal name: inline group.

    # Excutes in current context.

        a=0
        b=1
        { printf $a; printf $b; } | cat

    # Prints `01`.

    # Does not spawn a subshell.

##variable substitution ##${}

    # Replace a variable by its value.

        a="printf b"
        assert [ $($a) = b ]

    # Inside double quotes, variable substitution can happen.

        a=b
        b="$a"
        assert [ $b = b ]

        a=b
        b="${a}c"
        assert [ $b = bc ]

    # Cannot happens inside single quoted strings.

    # Escape:

        a=b
        assert [ "\$a" = '$a' ]

    # Single dollars become literal dolars:

        assert [ "$"  = "\$" ]
        assert [ "$ " = "\$ " ]

    # But I woud not rely on such obscure behaviour.

##command substitution ##`` ##$()

    #<http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_03>

    ##backquote

        #same as <#eval expression>

            assert [ `echo a` = a ]

        #external double quote not assumed.

            assert [ ! `echo "a b"`  = "a b" ]
            assert [ "`echo "a b"`" = "a b" ]

        #inner double or single quotes are fine:

            assert [ "`echo "a b"`" = "a b" ]
            assert [ "`echo 'a b'`" = "a b" ]

        #inner backquotes are not fine:

            #`echo `echo a``

        #this is why `$()` is better: you can nest it because it has an open/close pair:

            #$( echo $( echo a ))

        #therfore consider always using `$()`

    #$()

        #Similar to backquote:

            assert [ "$(echo abc)" = "abc" ]
            assert [ "`echo abc`"  = "abc" ]

        #Better than backquote because it can be nested:

            assert [ "$(echo $(echo a))" = "a" ]

        #Trailing newlines **are removed**!:

            assert [ a"$(printf "\n\n")" = "a" ]

##process substitution

    # bash extension.

    # Expands a line of the type `<(echo a)` to either a FIFO or a `/dev/fd`
    # open file descriptor that contains whatever was echoed.

    # Typical application: pass variables as file contents to utilities
    # that expect files.

        echo "Process substitution:"
        A="file content"
        echo <(echo "$A")
            # Possible output:
            #/dev/fd/63
        assert [ "$(cat < <(echo "$A"))" = "$A" ]

##string

    ##interpret scapes sequences

        #`$'` strings interpret backslash escapes:

            a=b
            echo $'$a\nb'

        #but `$` is not interpreted as a variable

        #double quote analogue does not exist:

            a=b
            #echo $"a\nb"

        #solution: use `echo -e`:

            a=b
            echo -e "$a\nb"

    #null charcter shorthand:

        assert [ '' = $'\0' ]

    #string length

        s='abcd'
        assert [ ${#s} -eq 4 ]

    #substrings:

        s='abcd'
        assert [ ${s:0:1}   = a   ]
        assert [ ${s:1:1}   = b   ]
        assert [ ${s:0:2}   = ab  ]
        assert [ ${s:2}     = cd  ]

    ##glob operations

        #you can do certain glob operations on strings

            s='12223'

        #remove shortest matching preffix

            assert [ ${s#1*2} = 223 ]

        #mnemonic: `#` (under 3) comes before `%` (under 5),
        #so it is the prefix, and not suffix

        #remove longest matching preffix

            assert [ ${s##1*2} = 3 ]

        #mnemonic: two `##` is for long, one `#` is for short

        #remove shortest matching suffix:

            assert [ ${s%2*3} = 122 ]

        #remove shortest matching suffix:

            assert [ ${s%%2*3} = 1 ]

        ##applications

            #get file extension or path without the extension:

                s='a/b.ext'
                assert [ ${s%.*} = a/b ]
                assert [ ${s##*.} = ext ]

##expansion

    ##pathname expansion ##globbing

        #formal name: #<pathname expansion>

        #simple regex like expanded before command is evaluated

        #nonhidden files cur dir:

            echo *

        #hidden in files cur dir. Includes the annoying `.` and `..`:

            echo .*

        #hidden files cur dir except `.` and `..`: <http://stackoverflow.com/questions/2910049/how-to-use-the-wildcard-in-bash-but-exclude-the-parent-directory>

            echo .[^.]* ..?*

        # Consequence of the above: all files in current dir except `.` and `..`:

        #all files in cur dir except `.` and `..`:

            #- `ls -A` is good but fails if filenames have spaces

            echo * .[^.]* ..?*

        # This is really horrible when listing a given directory since it
        # requires to repeat it 3 times (there is no alternation for basic glob):

            echo a/* a/.[^.]* a/..?*

        # Escape:

            echo '*'
            echo "*"

        #start with a:

            echo a*

        #second letter a:

            echo ?a*

        #* matches "".

        #start with a or b:

            echo [ab]*

        #start with 0, 1 or 2.

            echo [0-2]*

        #works with vars:

            a=b
            "$a"*

        #shows all the files that start with b

        #only nonhidden:

        ##combos

            #for loop in cur dir:

                for f in .* *; do echo "$f"; done

        ##extended globbing

            #glob with ERE-like expressions instead of BREs

            #activate:

                shopt -s extglob

            #glob              ERE mnemonic
            #?(pattern-list)   (...|...)?
            #*(pattern-list)   (...|...)*
            #+(pattern-list)   (...|...)+
            #@(pattern-list)   (...|...)    [@ not a RE syntax]
            #!(pattern-list)   "!" used as for negative assertions in RE syntax

    ##tilde expansion

            assert [ "`sudo -u a echo ~`"  = /home/a ]
            assert [ "`echo ~a`" = /home/a ]
            assert [ "`echo ~root`" = /root ]
            assert [ "`echo ~homeless`" = '~homeless' ]

        #escape:

            assert [ "`echo "~a"`" = "~a" ]

        #*obvioustly* this does not work from scripts since scripts can be run as any user

    ##brace expansion

        #{}

        #quite useful

        ##alternatives

                assert [ "`for a in 0{ab,cd}1; do echo -n "$a "; done`" = $'0ab1 0cd1 ' ]

            #nested is ok:

                assert [ "`for a in 0{a,{b,c}}1; do echo -n "$a "; done`" = $'0a1 0b1 0c1 ' ]

        ##number ranges

                assert [ "`for a in a{1..3}b; do echo -n "$a"; done`" = $'a1b a2b a3b ' ]
                assert [ "`for a in a{-1..-3}b; do echo "$a"; done`" = $'a-1b\na-2b\na-3b' ]
                assert [ "`for a in a{1..5..2}b; do echo "$a"; done`" = $'a1b\na3b\na5b' ]
                assert [ "`for a in a{5..1..2}b; do echo "$a"; done`" = $'a5b\na3b\na1b' ]

        ##letter ranges

                assert [ "`for a in 0{a..c}1; do echo "$a"; done`" = $'0a1\n0b1\n0c1' ]
                assert [ "`for a in 0{a..e..2}1; do echo "$a"; done`" = $'0a1\n0c1\n0e1' ]

        #escape:

            echo "{1..3}"

        #applications:

            for i in {1..5}; do echo $i; done

            mkdir very/long/path/{a,b}

            cp a{,.bak}

##list

    #declare all:

        a=()
        a=( a b c "d d" )

    #cannot nest:

        #a=( (b) (c) )

    #declare elements:

        a[10]=b
        a[20]=c

    #cannot nest:

        #a[0]=(1 2)

    #concat:

        a+=( "e e" )

    #access:

        a[0]=1
        a[1]=2
        a[2]=3
        assert [ ${a[0]} = 1 ]
        assert [ ${a[1]} = 2 ]
        assert [ ${a[2]} = 3 ]

    #`{}` is obligatory here

    #loop:

        is=( a b "a b" )
        for i in "${is[@]}"; do echo $i; done
        #a
        #b
        #a b

        for i in "${a[@]}"; do echo $i; done
        #four lines. @ with quotes "" expands similary to "$@"
        #quotes for each element are actually put on the terminal

    #range:

        echo ${a[@]:1}

        echo ${a[@]:1:2}

##map ##associative array

        declare -A aa
        aa=([a]=1 [b]=2)
        assert [ ${aa[a]} = 1 ]
        assert [ ${aa[b]} = 2 ]

##string

    #equality:

        assert [ abc = abc ]

    #glo boes not work:

        assert [ ! abc = a*c ]

    #check empty:

        assert [ -z "" ]
        assert [ ! -z "a" ]

    ##double square brackets

        #glob works:

            assert [[ abcd == a*d ]]
            assert [[ abc == a?c ]]
            assert [[ abc == a[bB]c ]]

        #cannot quote right:

            assert [[ abcd != "a*d" ]]

##true ##false

    #false it is a program that does one thing: ``exit(1);`` !

    #very useful with bash

        which true

        assert [ `if true; then echo a; fi` = a ]
        assert [ -z `if false; then echo a; fi` ]

        v=true
        assert [ `if $v; then echo a; fi` = a ]

##square brackets

    #bash built-in

    #does the same as [test]

        [ 1 = 1 ]
        [ $? = 0 ]
        if [ 1 = 1 ]; then echo true; fi
        if [ ! 1 = 1 ]; then echo true; fi

    #integer

            assert [ 1 -eq 1 ]
            assert [ 1 -lt 2 ]
            assert [ 2 -gt 2 ]
            assert [ 1 -le 2 ]
            assert [ 2 -ge 2 ]

##arithmetic

    ##let

        #comput and assign arigthmetic

                let i=1+1
                let i=i+1
                [ $i -eq 3 ] || echo fail

        #this is the nicest way to do it i think

        #NO SPACES ALLOWED! all fail:

            #let i =1+1
            #let i= 1+1
            #let i=1 +1

    #double parenthesis

        [ $(( 1+1 )) -eq 2 || echo fail

        (( 1>2 )) || echo fail

    #double square brackets

        #aka #[[

        #aka #extended logical test

##boolean

    #&& only execute next command if previous command gives status = 1
    #||                                                            = 0

    #if they don't execute, status is unchanged

    #therefore, for if ``&&`` has the same effect as and and ``||`` the same effect as or!

        assert [ `true && echo a` = a ]
        assert [ -z `false && echo a` ]
        assert [ `false || echo a` = a ]
        assert [ -z `true || echo a` ]

        assert [ `if true && true; then echo a; fi` = a ]
        assert [ -z `if false && true; then echo a; fi` ]
        assert [ -z `if true && false; then echo a; fi` ]
        assert [ -z `if false && false; then echo a; fi` ]

        assert [ `if true || true; then echo a; fi` = a ]
        assert [ `if false || true; then echo a; fi` = a ]
        assert [ `if true || false; then echo a; fi` = a ]
        assert [ -z `if false || false; then echo a; fi` ]

##colon

    #do nothing

        if true; then : ; fi

##case

    #each case is a <#pathname expansion> pattern
    #or an pattern | pattern (not a feature in regular glob):

        a=
        case $a in
            [a-c])
                echo "1"
                ;;
            [d-e]|[1-3])
                echo "2"
                ;;
            *)
                echo "3"
                ;;
        esac

    #single line:

        a=
        case $a in a) echo "1" ;; *) echo "2" ;; esac

##if

    #either:

        if false; then
            echo fail
        fi

    #or:

        if false; then
            echo fail
        fi

    ##not

        #! can be part of the if

        #note that [test] also understands !

            assert [ `if ! false; then echo a; fi` = a ]

##for while

        for f in a b; do echo "$f"; done
            #'a b'
        for f in 'a  b'; do echo "$f"; done
            #'a  b'

        echo {1..5..2}
            #'1 3 5'
        for i in {1..5..2}; do echo $i; done
            #$'1\n3\n5\n'

    #break:

        i=0
        while [ $i -lt 10 ]; do
                echo $i
                let i=i+1
                if [ $i -eq 5 ]; then
                    break
                fi
        done

##function

    #mandatory `;` on single line func:

        function f { echo $1; }

        function f
        {
            echo $1
        }

    #unbound variable:

        #f

        assert [ "`f a`"    = $'a' ]
        assert [ "`f a b`"  = $'a' ]

    #ERROR:

        #function f { echo $1; }

    #must have newlines.

##redirection

    # The following descriptors are always open by default:

    # - 0: stdin
    # - 1: stdout
    # - 2: stderr

    # Echo to stderr:

        echo "to stderr" 1>&2

    # Descriptor 3 to descriptor 4:

        echo a 3>&4

    # Descriptor 3 to file f:

        echo a 3>f

    # If input descrpitor is not given it defaults 1 (stdout). Decriptor 1 to file f:

        echo a >f

    # Descriptors 1 and 2 to file f:

        echo a &>f

    # Same as above but desincouraged by the manual since it breaks if file name is a number:

        echo a >&f

    # Append stdout to file:

        echo a >>"$f"

        function outerr {
            echo out
            echo err 1>&2
        }

        outerr
        #out
        #err

        outerr &>/dev/null
        #

        outerr >/dev/null
        #err

        outerr 2>/dev/null
        #out

    ##multiple redirections

        # The order of multiple redirections matters.

        # Think of them as variable assignments made from right to left.

            outerr >/dev/null 2>&1
            #

            outerr 2>&1 >/dev/null
            #err

    ##stdin redirection

        # Analogous to stdout redirection.

        # Get stdin of previous command from given file.

            printf abc >f
            assert [ $(cat <f) = abc ]

        # Combo combo with Process Substitution to pass a variable to stdin:

            assert [ $(cat < <(printf abc)) = abc ]

    ##| ##pipe

        # `a | b` connects stdout and stderr of `a` to stdin of `b`.

            assert [ "`outerr | cat`" = $'out\nerr' ]

        # Make a pipe take only stderr:

            outerr |& cat
            outerr >/dev/null | cat

    ##other fd

        # It is possible to create further file descriptors.

        # First, those descriptors must be made point somewhere,
        # or you get a `bad file descriptor error`:

            #echo a 1>&13

        # The usual way to use them is to redirect them to existing files or other
        # descriptors via the exec redirection combo.

        # From now on, redirect `3` to `1`:

            exec 3<&1

        # Echo to 3:

            echo 3 >&3

        # Close 3

            exec 3>&-

        # Open file `f` and assign fd 3 to it:

            exec 3<>f

        # Read the first line

            read <&3

        # Close `3`:

            exec 3>&-

    ##gotcha

        #YOU CANNOT MODIFY A FILE INLINE WITH REDIRECTION LIKE THIS:

            echo $'0\n1' > a
            grep 0 a | cat > a

        #this simply erases a

        #reason:

        #workaround: use sponge from moreutils.

##[]

    # Same interface as the `test` command.

##commands vs aliases vs built-ins vs keywords

    #- commands: programs in path. Ex: `ls`, `mkdir`

    #- aliases: declared with `alias a="b"`

        #subshells don't inherit aliases

        #one consequence of this is that they can only be run on interctive section,
        #not on scripts, which is exactly what they are inted to do!

    #- built-ins:

        #- hard coded in bash
        #- like commands
        #- examples:

            #cd, echo, let

        #good way to find that command is not a built-in:

                which cmd

        #if it has a path, then it is not a built-in

    #keywords:

        #- hard coded in bash
        #- not commands, but parts of commands
        #- examples: if, do, for, while, end*

    ##compgen

        #list all available commands / built-ins / functions / aliases,
        #in short, all "commands" you can issue from your shell

        #commands TODO

            #compgen -c

        #aliases

            #compgen -a

        #aliases and commands:

            #compgen -ac

        #built-ins

            #compgen -b

        #keywords

            #compgen -k

        #functions

            #compgen -A function

            #compgen -A function -abck #all above at once

    ##set

        #view/modify vars, functions and SHELLOPTS

        #list all vars and functions that are set

            set

        #sets the -e option:

            set -e

        #unsets the -e option:

            set +e

            man bash
            #/SHELLOPTS

    ##type

        #Tell type of command (shell keyword, shell buit-in, alias, function or executable in path.

            type if
                #keyword

            type cd
                #builtin

            alias a cd
            type a
                #alias

            function f { echo f; }
            type f
                #function

            type mkdir
                #shows path

        #`-t`: machine readable output
        #`-P`: forces to search PATH for command. possible application: detect if program is installed and in path:

            if [ "`type -P vim`" = "" ]; then
                echo 'vim not installed'
            fi

##alias

        alias echo="echo a"
        assert [ `echo` = a ]
        assert [ `echo b` = "a b" ]

    ##command

        #run without alias:

            assert [ `command echo b` = b ]

    ##unalias

            unalias echo
            assert [ `command echo a` = a ]

    ##aliases are not exported

            alias a="echo a"
            assert [ `a` = a ]
            bash
            assert [ `a` = a ]
            #not found, unless you have another a!

##rc files

    #are files that are automatically sourced at login

    ##~/.profile

        #sourced when root bash starts

        #therefore environment variables here are visible on all shells

        #this is differnt from bashrc, where your variables are only defined for interactive shells

        #so if for example you want to start some application in the ubuntu dash (win + type name + enter)
        #and you want your application to see enviroment variables you set, you **must** set them from
        #`.profile` and not from `.bashrc`, since your program was started from a non-interactive shell

    #~/.bashrc

        #sourced when each interactive bash starts

    #~/.bash_logout

        #sourced just before bash ends

##login shell

    #login shells source

    #/etc/profile

        #sourced by all login shells of all users

    #~/.bash_profile, ~/.bash_login, and ~/.profile
        #the first one *and only* the first one that is found and readable
        #is sourced by login shells of the user

    ##how to make a login shell

        #start your system with it

            bash -l

        #this is not usually necessary since exported environment variables
        #are inherited by child shells

##interactive shell

    #normally: a shell with std(in|out|err) linket to console

    #sources ``/etc/bash.bashrc`` and ``~/.bashrc`` in that order
    #after any login sources

    ##non-interactive

        #- does not source the interactive files,
        #- sources "$BASH_ENV" file if not empty

        #Can be started via subshells.

    ##how to start interactive bash:

        #the one you start your system with

            bash
            #you are now inside and interactive bash!

##environment variables

    #bash automatically sets lots of environment variables for its child processes.

    #commented list : <http://wikibash-hackers.org/syntax/shellvars>
    #also see man bash / shell variables.

    #home dir. /home/ciro/ for me:

        echo $HOME

    #cur username:

        echo $USER

    #cur hostname:

        echo $HOSTNAME

    #i686:

        echo $HOSTTYPE

        #x86_64

    #xterm on terminals run from x

        echo $TERM

    #not sure what it means

        #linux on ctrl+alt+f1 terminal

    #cur working dir. ``pwd``

        echo $PWD

    #last working dir. ``pwd``

        echo $OLDPWD

    #is printed on every terminal line:

        echo $PS1

    #may be very large due to coloring ansi coloring sequences.

    #second line terminal. default '>' !

        echo $PS2

    #list of current on bash options

        echo $BASHOPTS

    #readonly, modified indirectly by ``shopts``
    #on subshell startup, options in this list are set
    #``man bash`` ``/shopts`` for full list

    #similar to `BASHOPTS but set with ``set`` command instead:

        echo $SHELLOPTS

    #4.2.37(1)-release

        echo $BASH_VERSION

    #random number between 0 and 32767:

        echo $RANDOM
        echo $RANDOM

    #seconds since shell started:

        echo $SECONDS
        echo $SECONDS

    #en_US.UTF-8:

        echo $LANG

    #terminal width/height:

        echo $COLUMNS
        echo $LINES

    ##shlvl

        #depth level of cur shell

            assert [ "`echo $SHLVL`" = 1 ]
            bash
            assert [ "`echo $SHLVL`" = 2 ]
            exit
            assert [ "`echo $SHLVL`" = 1 ]
            bash &
            assert [ "`echo $SHLVL`" = 1 ]
            #does not increase
            #only increases in nested bashes
            kill %+

##tab expansion

    #Bash in interactive mode uses tab for command completion.

    #`sh` does not implement this, so this is not required by POSIX.

    #For example, if you type:

        #ec

    #and then hit `<tab>`, you will get a list like:

        #echo      eclipse   econvert

    #If there is only one possible command, it expands automatically.

    #To avoid this and insert a literal tab, do `<c-v><tab>`, in analogy to the other
    #escape characters input.

##exec

    #POSIX 7.

    # Interface similar to an exec system call:
    # ends current shell and runs given command instead

    # Destroys the calling bash!

        assert [ $SHLVL = 1 ]
        exec bash
        assert [ $SHLVL = 1 ]

    ##exec and redirection

        # Redirect all followint stdout to file a:

            #exec >f
            #printf a

    ##application

        # Start a new bash with a custom environment.
        # and discard the old one

            exec env -i a=b c=d bash --norc --noprofile
            env
            exit


##history

    ##fc

        #posix 7

            echo a
            fc
            #opens "echo a" in vim for editing
            #when you quit, executes what you wrote

        #set default editor

                FCEDIT=/bin/vi
                fc

    ##ctrl-r

        #*very useful*

        #good tutorial: <http://ruslanspivak.com/2010/11/20/bash-history-reverse-intelligent-search/>

##clear

    #clear terminal screen

            clear

##shopt

    ##builtin

        #show all options:

            shopt

        #set option:

            shopt -s op

        #unset option:

            shopt -u op

    ##hash

        # The first time bash calls an executable,
        # it searches the path for it.

        # It then stores the basename -> path
        # in a hashmap, and only uses the hashmap from then on.

        # If the command changes location, bash does not search for it
        # again, and just gives an error.

            set -h
            mkdir d
            echo "echo 2" > d/echon
            chmod +x d/echon
            PATH="$PATH:`pwd`:`pwd`/d"
            assert [ `echon` = 2 ]
            for i in {}
            echo "echo 1" > echon
            chmod +x echon
            assert [ `echon` = 2 ]
            #surprise!
            rm -r d
            rm echon

            #./echon is first in path
            #and sould print 1!

            #with `set -h`
            #bash does not search the path every time
            #it would take too long
            #it remembers paths!

        # Show usage count of used commands:

            hash

        # Forget all paths:

            hash -r

        # Forget path for a single command:

            hash -d firefox

##dirs stack

    #move between dirs in stack

    #builtins, not in `sh`

    #show dir stack

        dirs

    # -v : verbose. one per line, with line numbers:

        dirs -v

    #push to dir stack

        pushd .

    #pop fro dir stack and cd to it

        popd

    #very useful in when you need to cd somewherelse and come back later:

        pushd .
            cd d
            pwd
            pushd .
                cd d2
                pwd
            popd
        popd

echo '
ALL ASSERTS PASSED'
