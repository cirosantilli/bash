#!/usr/bin/env bash
#^^
#1
#1: shebang

##shebang

  #she: name for '#', bang: name for '!'

  #tells linux which interpreter to use to run the program

  #*must* be first line

  #if this were a phython script for example,
  #we'd use ``/bin/python``

  ##env

    #you could use ``!#/bin/bash`` instead
    #but if you go on a system where bash is located
    #at ``/usr/bin/bash``, your script breaks

    #with env, path is used instead
    #so if ``bash`` is in the users $PATH,
    #and /usr/bin/env exists 
    #it works

    #the advantage of this is that:
      #- env is more often located in ``/usr/bin`` than bash in ``/usr`` acros *NIX TODO check
      #- all you interpreters

  ##why not from extension

    #in windows, interpreter is determined by extension

    ##advantage os extension
    
      #easier to spot program type.

    ##disadvantage os extension

      #you need an extra EXT env var that says: you can execute a.py as py, a.sh as a

      #it is important to execute a.sh as ``a`` because if someday you decide that
      #it sould be written in python istead, you don't break all dependant programs
      #by using ``a.py``

#no complex programs shown: only language "basics"

#sources

  #<http://tldp.org/LDP/abs/html/abs-guide.html>

# bash shell follows POSIX standards
  #this includes common commands such as ``ls``, ``cd`` and many more
  #full list:
    #<http://pubs.opengroup.org/onlinepubs/9699919799/>

set -u # error on undefined variable1&>2
set -e # stop execution if one command return != 0

function init_test {
  wd="`pwd`"
  tmp="`mktemp -d`"
  cd $tmp
}

function cleanup_test {
  cd "$wd"
  rm -r "$tmp"
}

#execute outside path
  
  echo "echo a" > a
  chmod 777 a
  ./a
    #a

##variables

  a="abc"
  assert [ $a = abc ]

  a="abc"
  assert [ "0${a}1" = "0abc1" ]

  #you can use vars as commands

    a="echo b"
    $a
      #b
    #assert [ `$a` = b ]
    #assert [ $(a) = b ]
    #assert [ "$a"   = "echo b" ]

  #vars are not expand recursivelly
  
    b=c
    a='$b'
    assert [ "$a" = '$b' ]
    a="$b"
    assert [ "$a" = c ]

  ##unset

    a=b
    unset a
    assert [ -z "`echo $a`" ]

  ##readonly

    readon=b
    readonly readon
    #readon=c
      #error: a is readonly

    #TODO how to undo readonly?

  ##special vars

    ##$0

      #path of cur scrip relative to cd

      echo '#!/bin/bash
  echo "$0"' > a
      chmod +x a
      ./a
        #./a

      DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
        #for the full path

    ##$1

      echo '#!/bin/bash
  echo "$1"
  echo "$2"' > a
    ./a a b
      #a
      #b

    ##$#

      #number of cli args

      echo '#!/bin/bash
  echo "$#"' > a
      ./a a b
        #2
      ./a a b c d
        #4

      #usage

        #safe opt arg getting with shift

        if [ $# -gt 0 ]; then
          arg1="$1"
            #argument 1
          shift
            #destroy arg 1
        fi

        if [ $# -gt 0 ]; then
          arg2="$1"
            #argument 2
          shift
            #destroy arg 2
        fi

    ##$*

      DJVU_PATH="$*"
        #List of all arguments separated by SPACES.
        #Each argument is NOT quoted individually. 

    ##$@

      DJVU_PATH="$@"
        #List of all arguments separated by SPACES.
        #Each argument IS quoted individually.

    #$?
    
      #exit status of last program run

      if echo a | grep a ; then : ; fi
      echo $?
        #0
      if echo a | grep b ; then : ; fi
      echo $?
        #1

    ##$$

      current_process="$$"
        #returns current process name. Useful to create unique temporary files that have a recognizable component.

      TFILE="/tmp/$(basename $0).$$.tmp"
        #APPLICATION
        #create temp filename

    ##PPID

      echo $PPID
        #id of parent process
        #linux processes contain this info

    ##LINENO

      #cur line number!

      echo $LINENO

##quoting

  ##double

    ##space to var

      a="a b"
      assert [ "$a" = "a b" ]

    ##dollar interpreted

      a=b
      b="$a"
      assert [ $b = b ]

    ##dollar backlash escaped

      a=b
      assert [ "\$a" = '$a' ]

    ##single dollar ok

      assert [ "\$" = "$" ]

    ##backslash not interpreted

      echo "a\nb"
        #ab

  ##single

    #dollar not interpreted
    a=b
    b='$a'
    assert [ "$b" = '$a' ]

  ##dollar single

    #interprets backslash

    #does not interpret dollars

    #backquote assumed

    a=$'a\nb'
    assert [ "$a" = `echo -e "a\nb"` ]
      #not "$'a\nb'" = ...

    #cannot be quoted

    assert [ "$'a'" = "'\$a'" ]

  ##back

    #same as <#eval expression>
    assert [ `echo a` = a ]

    #external double quote not assumed
    assert [ ! `echoa "a b"`  = "a b" ]
    assert [  "`echoa "a b"`" = "a b" ]

    #double quote escape not needed
      assert [ "`echoa "a b"`" = "a b" ]
    #not:
      #assert [ "`echoa \"a b\"`" = "a b" ]

#parenthesis

  #spawn subshell

  cd; pwd
    #changes current dir
    #prints previous dir
  ( cd; pwd )
    #does not  change current dir
    #but still prints home

  #equivalent to
    bash -c 'cd; pwd'
  #EXCEPT you don't have to do escaping or quoting!

##evaluate expression

  #$()

  assert [ "$(echo abc)" = "abc" ]
  assert [ "`echo abc`"  = "abc" ]

##eval

  #exec string in current bash

  eval "a=b"
  assert [ $a = b ]

  ##applications

    #make varname from var

    a=b
    eval "$a=c"
    assert [ $b = c ]

##string

  ##interpret scapes

    echo $'$a\nb'
      #no $ expansion
    #echo $"a\nb"
      #does not exist
    a=b
    echo -e "$a\nb"
      #solution
    assert [ '' = $'\0' ]
      #null charcter

  s='abcd'
  echo ${#s}
    #4
      #string length
  echo ${s:0:1}
    #a
  echo ${s:1:1}
    #b
  echo ${s:0:2}
    #ab
  echo ${s:2}
    #cd

  ##string shell glob operations

    s='abcd'
    echo ${s#pattern}
    echo ${s##pattern}
    echo ${s%pattern}
    echo ${s%%pattern}

    ##applications
     
      #get file extension or path without extension

  s='a/b.ext'
  echo ${s%.*}
    #a/b
      #simple remove ext

echo glob

  #formal name: pat expansion

  #simple regex like expanded before command is evaluated

  echo *
    #files cur dir
  echo '*'
    #literal
  echo a*
    #start with a
  echo ?a*
    #second letter a
    #* matches ""
  echo [ab]*
    #start with a or b
  su a
  echo ~
    #/home/a
  echo ~test
    #/home/test
  echo ~root
    #/root
  echo ~idonthaveahome
    #~idonthaveahome
  
  #combos:

    for f in *; do echo "$f"; done
      #only non hidden
    for f in .*; do echo "$f"; done
      #only hidden
    for f in * .*; do echo "$f"; done
      #both hidden and not hidden

  ##extended globbing

    #glob with ERE-like expressions instead of BREs

    shopt -s extglob
      #extended globbing

      #glob              ERE mnemonic
      #?(pattern-list)   (...|...)?
      #*(pattern-list)   (...|...)*
      #+(pattern-list)   (...|...)+
      #@(pattern-list)   (...|...)    [@ not a RE syntax]
      #!(pattern-list)   "!" used as for negative assertions in RE syntax

##brace expansion

  #{}

  ##alternatives

    assert [ "`for a in 0{ab,cd}1; do echo -n "$a "; done`" = $'0ab1 0cd1 ' ]

    ##nested ok

      assert [ "`for a in 0{a,{b,c}}1; do echo -n "$a "; done`" = $'0a1 0b1 0c1 ' ]

  ##number ranges

    assert [ "`for a in a{1..3}b; do echo -n "$a"; done`" = $'a1b a2b a3b ' ]
    assert [ "`for a in a{-1..-3}b; do echo "$a"; done`" = $'a-1b\na-2b\na-3b' ]
    assert [ "`for a in a{1..5..2}b; do echo "$a"; done`" = $'a1b\na3b\na5b' ]
    assert [ "`for a in a{5..1..2}b; do echo "$a"; done`" = $'a5b\na3b\na1b' ]

  ##letter ranges

    assert [ "`for a in 0{a..c}1; do echo "$a"; done`" = $'0a1\n0b1\n0c1' ]
    assert [ "`for a in 0{a..e..2}1; do echo "$a"; done`" = $'0a1\n0c1\n0e1' ]

  ##applications

    for i in {1..5}; do echo $i; done

    mkdir a{a..c}
    
echo array

  #declare
    a=()
    a=( a b c "d d" )

  a+=( "e e" )
    #append

  #access

  a[0]=1
  a[1]=2
  a[2]=3
  assert [ ${a[0]} = 1 ]
  assert [ ${a[1]} = 2 ]
  assert [ ${a[2]} = 3 ]
    #{} is obligatory here

  is=( a b "a b" )
  for i in "${is[@]}"; do echo $i; done
    #a
    #b
    #a b

  for i in "${a[@]}"; do echo $i; done
    #four lines. @ with quotes "" expands similary to "$@"
    #quotes for each element are actually put on the terminal

  echo ${a[@]:1}
    #subarray

  echo ${a[@]:1:2}
    #subarray: from 1, select 2

  #associative array
  declare -A aa
  aa=([hello]=world [ab]=cd)
  echo ${aa[hello]}
    #world
  echo ${aa[ab]}
    #cd

echo string

  if [ abc = abc ]; then echo true; fi
  if [ abc = a*c ]; then echo false; fi
    #no glob pattern

  if [[ abcd == a*d ]]; then echo true; fi
  if [[ abc == a?c ]]; then echo 'abc == a?c'; fi
  if [[ abc == a[bB]c ]]; then echo 'abc == a[bB]c'; fi
    #shell glob pattern

  if [[ abcd == "a*d" ]]; then echo false; fi 
    #don't quote right

  a=""
  if [ -z "$a" ]; then echo true; fi
  a="not empty"
  if [ -z "$a" ]; then echo true; fi

#if

  [ 1 = 1 ]
  [ $? = 0 ]
    #[ ] is an external program
    #it retunrs an exit status

  #[ 1 = 0 ]
    #program ends because of -e

  v=false
  v=true
  if $v; then
    echo "true"
  fi

  #integer

    if [ 1 -eq 1 ]; then echo true; fi
    if [ 1 -lt 2 ]; then echo true; fi
    if [ 2 -gt 2 ]; then echo true; fi
    if [ 1 -le 2 ]; then echo true; fi
    if [ 2 -ge 2 ]; then echo true; fi

  #&& and ||

    #&& only execute next command if previous command gives status = 1
    #||                                                            = 0

    #if they don't execute, status is unchanged

    true && echo a
      #a
    false && echo a
      #
    true || echo a
      #
    false || echo a
      #a

  #logical

    a=true
    if [ ! a = b ]; then echo true; fi
      #not
    if [ a = a ] && [ b = b ]; then echo true; fi
      #and
        #actually, if first is true do seconde
        #else skip
        #this has same effect as and
    if [ a = b ] || [ b = b ]; then echo true; fi
      #or
        #actually, if first is true, skip
        #else do second
        #this has same effect as or

  ##true false

    which true
      #/bin/true
      #it is a program that does one thing: ``exit(1);`` !

  ##test

    #compare values and check files, answer on exit status

    #has built-in form in bash since it is so useful for bash: [ ]

    #but test is a program!

    which test
      #/bin/test

    #value compare
      test a = a && echo a
        #a
      test a = b && echo a
        #

    #file ops

      #-f

        #exists and is regular file

        init_test
        touch a
        assert test -f a
        cleanup_test

      #-s

        #exists and has size > 0

        rm -rf a
        touch a
        assert test -f a

    #logical
      test ! a = a        && echo a
        #
      test a = a -a b = b && echo a
        #a
      test a = a -a a = b && echo a
        #
      test a = a -o a = b && echo a
        #a
      test a = b -o a = b && echo a

  #colon

    #do nothing

    if true; then : ; fi

##for while

  for f in a b; do echo "$f"; done
    #'a b'
  for f in 'a  b'; do echo "$f"; done
    #'a  b'

  echo {1..5..2}
    #'1 3 5'
  for i in {1..5..2}; do echo $i; done
    #$'1\n3\n5\n'

  i=0
  while [ $i -lt 10 ]; do
      echo $i
      let i=i+1 
      if [ $i -eq 5 ]; then
        break
      fi
  done

#arithmetic

  TWO=$(( 1+1 ))
  echo $TWO
    #obviously, bash was not made with this in mind, VERY cumbersome.
    #bash is all about strings and files, not numbers. 

  if (( 1>2 )); then echo '1>2'; fi

  #let
    let i=1+1
    let i=i+1
    echo $i
    #3

  #[[ ]] extended logical test

#functions

  function f {
    echo f $1
  }

  #f
    #unbound
  f a
    #f a
  f a b
    #f a

#redirection

  #0: stdin
  #1: stdout
  #2: stderr

  #applications

    #echo to stderr

    echo "to stderr" 1>&2

  M=1
  N=2
  f=file
  echo a "$M">&"$N"
    #descriptor M to descriptor N
  echo a "$M">"$f"
    #descriptor M to file f
  echo a >&"$N"
  echo a >"$f"
    #defaults to descriptor 1 (stdout)
  echo a &>"$f"
    #descriptors 1 and 2
  echo a >>"$f"
    #append stdout to file

  #descriptors
    function outerr {
      echo out
      echo err 1>&2
    }

    outerr
      #out
      #err
    outerr &>/dev/null
      #
    outerr >/dev/null
      #err
    outerr 2>/dev/null
      #out
    outerr >/dev/null 2>&1
      #
      #writes stderr *and* stdout to /dev/null
      #- first redirects stderr to stdout
      #- then stdout to f
      #so they both go to f
      #rightmost comes first

  #< input

    cat <"$f"
      #file f to stdin
    cat < <(echo -e "a\nb\na b")
    echo -e "a\nb\na b" | cat 
      #echo to stdin

  #| pipe

    assert [ "`outerr | cat`" = $'out\nerr' ]
      #out
      #err
        #pipes out *and* err
    outerr |& cat
    outerr >/dev/null | cat
      #err

  #other fd
    exec 3<&1
      #create 3
      #write 3 to 1
    echo 3 >&3
      #1 to 3 to 1
    exec 3>&-
      #close 3

    exec 3<> "$f"
      #open f and assign fd 3 to it
    read <&3
      #read the first line
    exec 3>&-
      #close 3
    echo $REPLY

#background

  #jobs
    #shows jobs running on background of cur bash
    #
    #%N	Job number [N]
    #%S	Invocation (command line) of job begins with string S
      #if several matches, ambiguous, and does nothing
    #%?S	Invocation (command line) of job contains within it string S
    #%%	"current" job (last job stopped in foreground or started in background)
    #%+	"current" job (last job stopped in foreground or started in background)
    #%-	Last job
    #$!	Last background process
    #
    #shows:
    #  jobspec : local id
    #  status : runnning, stopped, done
    #  invocation : exact program call, including command line args. Ex: ``ls ~``

  #ls &
  #sleep 100 &
  #sleep 100 &
  #sleep 100 &
    #runs on background
    #
    #[1] 12345678
    #means local id 1
    #process number 12345678
    #
    #when process ends, it prints ``[n] 1234`` and disappears
    #
    #stdout continues to go to cur terminal, even if in bg

  #firefox
    #Ctrl z
    #puts currently foreground running on background stopped

  #bg %3
    #starts running job 3 which was stopped on background
  #bg
  #bg %+
  #bg %%
    #last bg job [+]
  #bg %-
    #before last bg job [-]

  #fg %3
    #starts running job 3 which was on background on foreground
  #fg
    #last job

  #kill %1
    #kill subprocess [1]
  #kill $PID
    #kill by process id

  #wait && ls
    #wait for all bg jobs to finish
  #wait %3 && ls
    #job 3

  #vlc 100 &
  #vlc 100 &
  #vlc 100 &
  #disown %3
    #remove job 3 from list of sub jobs
    #closing bash will not kill it anymore

#list available commands

  #commands: programs in path
  #aliases: alias a="b"
    #can only be run on interctive section, not on scripts
  #built-ins: 
    #hard coded in bash
    #like commands
    #examples:
      #echo, printf, read
      #let, eval, set export

    ##good way to find that command is not a built-in:
      which cmd
      #if it has a path, then it is not a built-in
  #keywords: 
    #hard coded in bash
    #not commands, but parts of commands
      #if, do, for, while, end*
    #source:
      #http://tldp.org/LDP/abs/html/internal.html

  #compgen -c #commands
  #compgen -a #aliases
  #compgen -ac #both
  #compgen -b #built-ins
  #compgen -k #keywords
  #compgen -A function #functions
  #compgen -A function -abck #all above at once

  ##set

    #view/modify vars, functions and SHELLOPTS

    set
      #list all vars and functions that are set
    set -e
      #sets the -e option
    set +e
      #unsets the -e option

    man bash
      #/SHELLOPTS

##alias

  alias echo="echo a"
  assert [ `echo` = a ]
  assert [ `echo b` = "a b" ]

  ##command

    assert [ `command echo b` = b ]
      #ignores aliases

  ##unalias

    unalias echo
    assert [ `command echo a` = a ]

##exec

  #bash interface similar to an exec system call

  #replaces cur process with the given process

  #destroying the caller bash!

  assert [ $SHLVL = 1 ]
  exec bash
  assert [ $SHLVL = 1 ]
  #exec bash
    #ls then exits bash!
    #you don't see anything

##login

  #login shells source:

  #/etc/profile
    #sourced by all login shells of all users
  #~/.bash_profile, ~/.bash_login, and ~/.profile
    #the first one *and only* the first one that is found and readable
    #is sourced by login shells of the user

  ##how to make a login shell:
    
    #start your system with it

    bash -l

    #this is not usually necessary since exported environment variables
    #are inherited by child shells

##interactive

  #normally: a shell with std(in|out|err) linket to console

  #sources ``/etc/bash.bashrc`` and ``~/.bashrc`` in that order
  #after any login sources

  ##non-interactive

    #does not source the interactive files,
    #but sources $BASH_ENV file if not empty

  ##how to start non interactive bash:

    ##subshells

      bash -c 'echo a'
      echo "echo a" | bash
      ( echo a )

  ##how to start interactive bash:

    #the one you start your system with

    bash
      #you are now inside and interactive bash!

##environment variables

  #huge list: <http://wiki.bash-hackers.org/syntax/shellvars>

  ##env

    env
      #shows all environment variables and their values

    #change environment for a single command

      a=b
      env a=c echo $a
        #c
      echo $a
        #b
    
    ##-i
    
      #exec in a clean environment

      assert [ "`env -i a=b env`" = "a=b" ]

      ##start a subshell in the cleanest env possible
      
        #don't forget: subshells inherit all exported vars

        env -i bash --noprofile --norc
        env
          #some default vars might still be there!
          #I get: SHLVL, PWD
        exit

  ##some important ones
    
    echo $HOME
      #home dir. /home/ciro/
    echo $USER
      #cur username. ciro
    echo $HOSTNAME
      #cur hostname. ciro-thinkpad
    echo $HOSTTYPE
      #i686
      #x86_64
    echo $SHELL
      #cur default shell. /bin/bash
    echo $TERM
      #xterm on terminals run from x
      #linux on ctrl+alt+f1 terminal
      #not sure what it means
    echo $PWD
      #cur working dir. ``pwd``
    echo $OLDPWD
      #last working dir. ``pwd``
    echo $PS1
      #is printed on every terminal line
      #very large due to coloring
    echo $PS2
      #second line terminal. default '>' !
    echo $BASHOPTS
      #list of current on bash options
      #readonly, modified indirectly by ``shopts``
      #on subshell startup, options in this list are set
      #``man bash`` ``/shopts`` for full list
    echo $SHELLOPTS
      #same as BASHOPTS
      #but set with ``set`` command instead
    echo $BASH_VERSION
      #4.2.37(1)-release
    echo $RANDOM
    echo $RANDOM
      #random number between 0 and 32767
    echo $SECONDS
    echo $SECONDS
      #seconds since shell started
    echo $LANG
      #en_US.UTF-8
    echo $COLUMNS
    echo $LINES
      #terminal width/height
    ##shlvl

      #depth level of cur shell
      
      assert [ "`echo $SHLVL`" = 1 ]
      bash
      assert [ "`echo $SHLVL`" = 2 ]
      exit
      assert [ "`echo $SHLVL`" = 1 ]
      bash &
      assert [ "`echo $SHLVL`" = 1 ]
        #does not increase
        #only increases in nested bashes
      kill %+

##history

  ##fc

    #posix 7
  
    echo a
    fc
      #opens "echo a" in vim for editing
      #when you quit, executes what you wrote
    
    #set default editor

      FCEDIT=/bin/vi
      fc

##clear

  #clear terminal screen

  clear

##shopt

  #builtin

  shopt
    #show options
  shopt -s op
    #set option
  shopt -u op
    #unset option
  
  ##hash

    set -h
    mkdir d
    echo "echo 2" > d/echon
    chmod +x d/echon
    PATH="$PATH:`pwd`:`pwd`/d"
    assert [ `echon` = 2 ]
    for i in {}
    echo "echo 1" > echon
    chmod +x echon
    assert [ `echon` = 2 ]
      #surprise!
    rm -r d
    rm echon

      #./echon is first in path
      #and sould print 1!

      #with ``set -h``
      #bash does not search the path every time
      #it would take too long
      #it remembers paths!
  
    #shows used commands in current session
    #with usage count
    
    hash

echo '
##################################################
# ALL ASSERTS PASSED
##################################################'
