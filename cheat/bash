#!/usr/bin/env bash

#no complex programs shown: only language "basics"

#sources

  #<http://tldp.org/LDP/abs/html/abs-guide.html>

# bash shell follows POSIX standards
  #this includes common commands such as ``ls``, ``cd`` and many more
  #full list:
    #<http://pubs.opengroup.org/onlinepubs/9699919799/>

set -u # error on undefined variable1&>2
set -e # stop execution if one command return != 0

OUT="./_out/"
mkdir -p "$OUT"
cd "$OUT"

#execute outside path
  
  echo "echo a" > a
  chmod 777 a
  ./a
    #a

#special vars

  #$0

    #path of cur scrip relative to cd

    echo '#!/bin/bash
echo "$0"' > a
    chmod +x a
    ./a
      #./a

    DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
      #for the full path

  #echo $1

    echo '#!/bin/bash
echo "$1"
echo "$2"' > a
  ./a a b
    #a
    #b

  #$#

    #number of cli args

    echo '#!/bin/bash
echo "$#"' > a
    ./a a b
      #2
    ./a a b c d
      #4

    #usage

      #safe opt arg getting with shift

      if [ $# -gt 0 ]; then
        arg1="$1"
          #argument 1
        shift
          #destroy arg 1
      fi

      if [ $# -gt 0 ]; then
        arg2="$1"
          #argument 2
        shift
          #destroy arg 2
      fi

  #$*

    DJVU_PATH="$*"
      #List of all arguments separated by SPACES.
      #Each argument is NOT quoted individually. 

  #$@

    DJVU_PATH="$@"
      #List of all arguments separated by SPACES.
      #Each argument IS quoted individually.

  #$?
  
    #exit status of last program run

    if echo a | grep a ; then : ; fi
    echo $?
      #0
    if echo a | grep b ; then : ; fi
    echo $?
      #1

  #$$

    current_process="$$"
      #returns current process name. Useful to create unique temporary files that have a recognizable component.

    TFILE="/tmp/$(basename $0).$$.tmp"
      #APPLICATION
      #create temp filename

  #PPID

    echo $PPID
      #id of parent process
      #linux processes contain this info

#variables

  a="abc"
  assert [ $a = abc ]

  a="abc"
  assert [ "0${a}1" = "0abc1" ]

  #you can use vars as commands

    a="echo b"
    $a
      #b
    assert [ $a = b ]
    assert [ `$a` = b ]
    assert [ $(a) = b ]
    assert [ "$a" = "echo b" ]

  #vars expand recursivelly
  
    a='$b'
    b=c
    assert [ $a = c ]
    b=d
    assert [ $a = d ]
    assert [ "$a" = d ]
    assert [ '$a' = '$b' ]

##quoting

  a="a b"
  assert "$a = \"a b\""

#() parenthesis

  #spawn subshell

  cd; pwd
    #changes current dir
  ( cd; pwd )
    #does not  change current dir
    #but still prints home

  #equivalent to
    bash -c 'cd; pwd'
  #EXCEPT you don't have to do escaping or quoting!

##$() eval expression

  assert [ "$(echo abc)" = "abc" ]
  assert [ "`echo abc`"  = "abc" ]

##string

  s=$'\n'
    #newline to var
  s=$'\0'
    #null to var
  s='abcd'
  echo ${#s}
    #4
      #string length
  echo ${s:0:1}
    #a
  echo ${s:1:1}
    #b
  echo ${s:0:2}
    #ab
  echo ${s:2}
    #cd

  ##string shell glob operations

    s='abcd'
    echo ${s#pattern}
    echo ${s##pattern}
    echo ${s%pattern}
    echo ${s%%pattern}

    ##applications
     
      #get/remove file extension

  s='a/b.ext'
  echo ${s%.*}
    #a/b
      #simple remove ext

echo glob

  #simple regex like expanded before command is evaluated

  echo *
    #files cur dir
  echo '*'
    #literal
  echo a*
    #start with a
  echo ?a*
    #second letter a
    #* matches ""
  echo [ab]*
    #start with a or b
  whoami
    #ciro
  echo ~
    #/home/ciro
  echo ~test
    #/home/test
  echo ~root
    #/root
  echo ~idonthaveahome
    #~idonthaveahome
  
  #combos:
    #for f in *; do echo "$f"; done
    #for f in .*; do echo "$f"; done
    #for f in * .*; do echo "$f"; done
    
echo array

  #declare
    a=()
    a=( a b c "d d" )

  a+=( "e e" )
    #append

  #access

  a[0]=1
  a[1]=2
  a[2]=3
  assert [ ${a[0]} = 1 ]
  assert [ ${a[1]} = 2 ]
  assert [ ${a[2]} = 3 ]
    #{} is obligatory here

  is=( a b "a b" )
  for i in "${is[@]}"; do echo $i; done
    #a
    #b
    #a b

  for i in "${a[@]}"; do echo $i; done
    #four lines. @ with quotes "" expands similary to "$@"
    #quotes for each element are actually put on the terminal

  echo ${a[@]:1}
    #subarray

  echo ${a[@]:1:2}
    #subarray: from 1, select 2

  #associative array
  declare -A aa
  aa=([hello]=world [ab]=cd)
  echo ${aa[hello]}
    #world
  echo ${aa[ab]}
    #cd

echo string

  if [ abc = abc ]; then echo true; fi
  if [ abc = a*c ]; then echo false; fi
    #no glob pattern

  if [[ abcd == a*d ]]; then echo true; fi
  if [[ abc == a?c ]]; then echo 'abc == a?c'; fi
  if [[ abc == a[bB]c ]]; then echo 'abc == a[bB]c'; fi
    #shell glob pattern

  if [[ abcd == "a*d" ]]; then echo false; fi 
    #don't quote right

  a=""
  if [ -z "$a" ]; then echo true; fi
  a="not empty"
  if [ -z "$a" ]; then echo true; fi

#if

  [ 1 = 1 ]
  [ $? = 0 ]
    #[ ] is an external program
    #it retunrs an exit status

  #[ 1 = 0 ]
    #program ends because of -e

  v=false
  v=true
  if $v; then
    echo "true"
  fi

  #integer

    if [ 1 -eq 1 ]; then echo true; fi
    if [ 1 -lt 2 ]; then echo true; fi
    if [ 2 -gt 2 ]; then echo true; fi
    if [ 1 -le 2 ]; then echo true; fi
    if [ 2 -ge 2 ]; then echo true; fi

  #&& and ||

    #&& only execute next command if previous command gives status = 1
    #||                                                            = 0

    #if they don't execute, status is unchanged

    true && echo a
      #a
    false && echo a
      #
    true || echo a
      #
    false || echo a
      #a

  #logical

    a=true
    if [ ! a = b ]; then echo true; fi
      #not
    if [ a = a ] && [ b = b ]; then echo true; fi
      #and
        #actually, if first is true do seconde
        #else skip
        #this has same effect as and
    if [ a = b ] || [ b = b ]; then echo true; fi
      #or
        #actually, if first is true, skip
        #else do second
        #this has same effect as or

  #true false

    which true
      #/bin/true
      #it is a program that does one thing: ``exit(1);`` !

  #test

    #compare values and check files, answer on exit status

    #has built-in form in bash since it is so useful for bash: [ ]

    #but test is a program!

    which test
      #/bin/test

    #value compare
      test a = a && echo a
        #a
      test a = b && echo a
        #

    #file ops
      rm -rf a
      touch a
      test -f && echo a
        #a

    #logical
      test ! a = a        && echo a
        #
      test a = a -a b = b && echo a
        #a
      test a = a -a a = b && echo a
        #
      test a = a -o a = b && echo a
        #a
      test a = b -o a = b && echo a

echo for while

  for f in "a b"; do echo $f; done
    #a b
      #separtes at line sep

  #for f in `ls -A`; do echo $f; done

  for i in `seq 1 10`; do echo $i; done

  i=0
  while [ $i -lt 10 ]; do
      echo $i
      let i=i+1 
  done

#arithmetic

  TWO=$(( 1+1 ))
  echo $TWO
    #obviously, bash was not made with this in mind, VERY cumbersome.
    #bash is all about strings and files, not numbers. 

  if (( 1>2 )); then echo '1>2'; fi

  #let
    let i=1+1
    let i=i+1
    echo $i
    #3

  #[[ ]] extended logical test

#functions

  function f {
    echo f $1
  }

  #f
    #unbound
  f a
    #f a
  f a b
    #f a

#redirection

  #0: stdin
  #1: stdout
  #2: stderr

  #applications

    #echo to stderr

    echo "to stderr" 1>&2

  M=1
  N=2
  f=file
  echo a "$M">&"$N"
    #descriptor M to descriptor N
  echo a "$M">"$f"
    #descriptor M to file f
  echo a >&"$N"
  echo a >"$f"
    #defaults to descriptor 1 (stdout)
  echo a &>"$f"
    #descriptors 1 and 2
  echo a >>"$f"
    #append stdout to file

  #descriptors
    function outerr {
      echo out
      echo err 1>&2
    }

    outerr
      #out
      #err
    outerr &>/dev/null
      #
    outerr >/dev/null
      #err
    outerr 2>/dev/null
      #out
    outerr >/dev/null 2>&1
      #
      #writes stderr *and* stdout to /dev/null
      #- first redirects stderr to stdout
      #- then stdout to f
      #so they both go to f
      #rightmost comes first

  #< input

    cat <"$f"
      #file f to stdin
    cat < <(echo -e "a\nb\na b")
    echo -e "a\nb\na b" | cat 
      #echo to stdin

  #| pipe

    outerr | cat
      #out
      #err
        #pipes out *and* err
    outerr >/dev/null | cat
      #err

  #other fd
    exec 3<&1
      #create 3
      #write 3 to 1
    echo 3 >&3
      #1 to 3 to 1
    exec 3>&-
      #close 3

    exec 3<> "$f"
      #open f and assign fd 3 to it
    read <&3
      #read the first line
    exec 3>&-
      #close 3
    echo $REPLY

#background

  #jobs
    #shows jobs running on background of cur bash
    #
    #%N	Job number [N]
    #%S	Invocation (command line) of job begins with string S
      #if several matches, ambiguous, and does nothing
    #%?S	Invocation (command line) of job contains within it string S
    #%%	"current" job (last job stopped in foreground or started in background)
    #%+	"current" job (last job stopped in foreground or started in background)
    #%-	Last job
    #$!	Last background process
    #
    #shows:
    #  jobspec : local id
    #  status : runnning, stopped, done
    #  invocation : exact program call, including command line args. Ex: ``ls ~``

  #ls &
  #sleep 100 &
  #sleep 100 &
  #sleep 100 &
    #runs on background
    #
    #[1] 12345678
    #means local id 1
    #process number 12345678
    #
    #when process ends, it prints ``[n] 1234`` and disappears
    #
    #stdout continues to go to cur terminal, even if in bg

  #firefox
    #Ctrl z
    #puts currently foreground running on background stopped

  #bg %3
    #starts running job 3 which was stopped on background
  #bg
  #bg %+
  #bg %%
    #last bg job [+]
  #bg %-
    #before last bg job [-]

  #fg %3
    #starts running job 3 which was on background on foreground
  #fg
    #last job

  #kill %1
    #kill subprocess [1]
  #kill $PID
    #kill by process id

  #wait && ls
    #wait for all bg jobs to finish
  #wait %3 && ls
    #job 3

  #vlc 100 &
  #vlc 100 &
  #vlc 100 &
  #disown %3
    #remove job 3 from list of sub jobs
    #closing bash will not kill it anymore


#list available commands

  #commands: programs in path
  #aliases: alias a="b"
    #can only be run on interctive section, not on scripts
  #built-ins: 
    #hard coded in bash
    #like commands
    #examples:
      #echo, printf, read
      #let, eval, set export
  #keywords: 
    #hard coded in bash
    #not commands, but parts of commands
      #if, do, for, while, end*
    #source:
      #http://tldp.org/LDP/abs/html/internal.html

  #compgen -c #commands
  #compgen -a #aliases
  #compgen -ac #both
  #compgen -b #built-ins
  #compgen -k #keywords
  #compgen -A function #functions
  #compgen -A function -abck #all above at once

echo '
##################################################
# ALL ASSERTS PASSED!
##################################################'
