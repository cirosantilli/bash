#!/usr/bin/env bash

#1 intro

# there are basically 3 parts to a find:
# find <where> <what> <do-what-with-finds>

find . -name '*' -print
# finds all files under current dir.

find .
# same as above. Default criteria is match anything (*) and default action is to print

#1 search criteria

#2 name and iname.

# match ENTIRE basenames posix expression

find . -name 'README'
# finds files named EXACTLY README. does not match README.txt

find . -name '*.txt'
# finds ENRTIRE basenames that match 'posix-exp' case sensitive. will NOT match ./asdf.txt.pdf

find . -iname '*.mp?'
# same as -name but case insensitive

#2 path. looks at whole file path posix expression

find . - path './*'
# finds anything under current dir. Note how relative paths all start with a dot slash './'

find . -path '*/.*'
# finds only paths are either hidden or have a hidden parent. alson consider prune for this.

find . -path './.vim/*'
# finds anything under ./.vim folder. same as find ./vim

#2 regex. looks at whole paths with posix regex

find . -regex '^/home/.*\.txt$'
# finds paths under /home, that end in .txt

#2 posix regex
# a posix expreis not a regexp: it has much less functions, including:
# * := .* of a regexp
# ? := . in a regexp

#2 type

find . -type f
# files only

find . -type d
# directories only

#2 maxdepth

find . -maxdepth 1
# find in current dir only

find . -maxdepth 2
# find in current and direct sons only

#2 prune

# do not search into directories that match what comes before prune.

# this is more efficient than using path to cut out directories.

# do not the -o 'or' operator after each prune.

find . -path '*/.*' -prune -o -type f -iname '*.txt'
# finds files that end in '.txt'
# does not go into directories whose -path '*/.*' is true (hidden dirs)
# INCLUDES hidden directories and hidden files themselfves which are not inside hidden directories!!! check next example for the correct method to avoid hiden files

find . '*/.*' -prune -o ! -name '.*'
# finds all files that are neither hidden themselves, nor are a child of a hidden parent. =)

find . '*/.*' -prune -o ! -name '.*'
# prunes with multiple criteria 

#2 -samefile

find . -xdev -samefile file1
# find all content (HASH) duplicates of file1

#1 multiple criteria

# you can concatenate multiple criteria logically.

#2 not !
find . -iname '*.pdf'
# find paths which are pdf and which are files. the and is implicit

#2 and -a implicit when no criteria is specified
find . -type f -iname '*.pdf'
# find paths which are pdf and which are files. the and is implicit

find . -type f -a -iname '*.pdf'
# same as above. the and is explicit here

#2 or -o

find . -iname '*.pdf' -o -iname '*.djvu'
# paths either terminated by pdf or djvu extension

find . -type f -iname '*.pdf' -o -iname '*.djvu'
# files only, either pdf of djvu extension. Therfore or has higher precedence over and.

#2 parenthesis

# you can change logical operation precedence with parenthesis.

# do not forget to escape your parenthesis!

find . \( -type f -iname '*.pdf' \) -o -iname '*.djvu'
# either files with extension pdf of paths (includes dirs) with extension djvu. Parenthesis are used to change precendence order.

#1 actions

# you can do things with the files you find. There are two main ways to do that: -exec and -print0 | xargs.

# xargs tends to be more flexible

find . -iname '*.tex' -exec pdflatex '{}' +
# compile all tex under current dir.
# {} gets expanded to the found path by -exec, and the commands ends when a trailling '+' is found

find . -iname '*.tex' -print0 | xargs -0 -I '{}' pdflatex '{}'
# does the same as above.
# -print0 prints files null (\0) terminated. this avoids problems since filenames that can contain newlines, but not null chars.
# -0 tells xargs that the input is null separated
# -I '{}' tells xargs that {} should be substituted by each arg one at a time

find . -iname '*.tex' -print0 | xargs -0 -I '{}' sh -c "bibtex '{}'; pdflatex '{}'"
# execute multiple commands for each argument of xargs. must use sh -c, it is the only way without an explicit loop.
# use this only for very simple multiple commands, or you are going to go crazy with quoting. for larger commands use an explicit loop as in next example.

while PATH in ( $( find . -iname '*.tex' -print0 | tr '\0' '" "' ) ); do echo "$PATH"; done
# BUG!! more complex commands inside a find loop
